<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PyGnome Class Reference &mdash; pyGNOME 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyGNOME 0.1.1 documentation" href="index.html" />
    <link rel="next" title="Units used in GNOME / PyGNOME" href="units.html" />
    <link rel="prev" title="A subsurface (mixed layer) release" href="scripting/mixedlayer_release.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units used in GNOME / PyGNOME"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="scripting/mixedlayer_release.html" title="A subsurface (mixed layer) release"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyGNOME 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pygnome-class-reference">
<h1>PyGnome Class Reference<a class="headerlink" href="#pygnome-class-reference" title="Permalink to this headline">¶</a></h1>
<p>There are a handful of core base classes in PyGnome.</p>
<div class="section" id="gnome-model-the-pygnome-model-class">
<h2><code class="docutils literal"><span class="pre">gnome.model</span></code> &#8211; the PyGnome model class<a class="headerlink" href="#gnome-model-the-pygnome-model-class" title="Permalink to this headline">¶</a></h2>
<p>This is the main class that contains objects used to model trajectory and
weathering processes. It runs the loop through time, etc.
The code comes with a full-featured version &#8211; you may want a simpler one if
you aren&#8217;t doing a full-on oil spill model. The model contains:</p>
<ul class="simple">
<li>map</li>
<li>collection of environment objects</li>
<li>collection of movers</li>
<li>collection of weatherers</li>
<li>a spills</li>
<li>its own attributes</li>
</ul>
<p>In pseudocode, the model loop is defined below. In the first step, it sets up the
model run and in subsequent steps the model moves and weathers elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start_at_step_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">if</span> <span class="n">step_num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">setup_model_run</span><span class="p">()</span>

<span class="k">else</span><span class="p">:</span>
    <span class="n">setup_time_step</span><span class="p">()</span>
    <span class="n">move</span><span class="p">()</span>
    <span class="n">weather</span><span class="p">()</span>
    <span class="n">step_is_done</span><span class="p">()</span>

<span class="n">step_num</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spills</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">release_elements</span><span class="p">()</span>     <span class="c"># initialize mover data arrays</span>

    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weatherers</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">initialize_data</span><span class="p">()</span>     <span class="c"># initialize weatherer data arrays</span>

<span class="n">o</span> <span class="o">=</span> <span class="n">write_output</span><span class="p">()</span>

<span class="k">return</span> <span class="n">o</span>
</pre></div>
</div>
<span class="target" id="module-gnome.model"></span><dl class="class">
<dt id="gnome.model.Model">
<em class="property">class </em><code class="descclassname">gnome.model.</code><code class="descname">Model</code><span class="sig-paren">(</span><em>time_step=None</em>, <em>start_time=datetime.datetime(2016</em>, <em>1</em>, <em>20</em>, <em>16</em>, <em>0)</em>, <em>duration=datetime.timedelta(1)</em>, <em>weathering_substeps=1</em>, <em>map=None</em>, <em>uncertain=False</em>, <em>cache_enabled=False</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>PyGnome Model Class</p>
<p>Initializes a model.
All arguments have a default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_step=timedelta(minutes=15)</strong> &#8211; model time step in seconds
or as a timedelta object</li>
<li><strong>start_time=datetime.now()</strong> &#8211; start time of model, datetime
object. Rounded to the nearest hour.</li>
<li><strong>duration=timedelta(days=1)</strong> &#8211; How long to run the model,
a timedelta object.</li>
<li><strong>weathering_substeps=1</strong> (<em>int</em>) &#8211; How many weathering substeps to
run inside a single model time step.</li>
<li><strong>map=gnome.map.GnomeMap()</strong> &#8211; The land-water map.</li>
<li><strong>uncertain=False</strong> &#8211; Flag for setting uncertainty.</li>
<li><strong>cache_enabled=False</strong> &#8211; Flag for setting whether the model should
cache results to disk.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="gnome.model.Model.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore model from previously persisted _state</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets model to defaults &#8211; Caution &#8211; clears all movers, spills, etc.
Takes same keyword arguments as <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewinds the model to the beginning (start_time)</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.uncertain">
<code class="descname">uncertain</code><a class="headerlink" href="#gnome.model.Model.uncertain" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncertainty attribute of the model. If flag is toggled, rewind model</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.cache_enabled">
<code class="descname">cache_enabled</code><a class="headerlink" href="#gnome.model.Model.cache_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>If True, then generated data is cached</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.has_weathering_uncertainty">
<code class="descname">has_weathering_uncertainty</code><a class="headerlink" href="#gnome.model.Model.has_weathering_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#gnome.model.Model.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Start time of the simulation</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.time_step">
<code class="descname">time_step</code><a class="headerlink" href="#gnome.model.Model.time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>time step over which the dynamics is computed</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.current_time_step">
<code class="descname">current_time_step</code><a class="headerlink" href="#gnome.model.Model.current_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Current timestep of the simulation</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.duration">
<code class="descname">duration</code><a class="headerlink" href="#gnome.model.Model.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>total duration of the model run</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.map">
<code class="descname">map</code><a class="headerlink" href="#gnome.model.Model.map" title="Permalink to this definition">¶</a></dt>
<dd><p>land water map used for simulation</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.model.Model.num_time_steps">
<code class="descname">num_time_steps</code><a class="headerlink" href="#gnome.model.Model.num_time_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Read only attribute
computed number of timesteps based on py:attribute:<cite>duration</cite> and
py:attribute:<cite>time_step</cite></p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.contains_object">
<code class="descname">contains_object</code><span class="sig-paren">(</span><em>obj_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.contains_object"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.contains_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gnome.model.Model.find_by_class">
<code class="descname">find_by_class</code><span class="sig-paren">(</span><em>obj</em>, <em>collection</em>, <em>ret_all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.find_by_class"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.find_by_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Look for an object that isinstance() of obj in specified colleciton.
By default, it will return the first object of this type.
To get all obects of this type, set ret_all to True</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.find_by_attr">
<code class="descname">find_by_attr</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em>, <em>collection</em>, <em>allitems=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.find_by_attr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.find_by_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>find first object in collection where the &#8216;attr&#8217; attribute matches
&#8216;value&#8217;. This is primarily used to find &#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217;
objects in environment collection. Use the &#8216;_ref_as&#8217; attribute to
search.</p>
<p>Ignore AttributeError since all objects in collection may not contain
the attribute over which we are searching.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attr</strong> (<em>str</em>) &#8211; attribute whose value must match</li>
<li><strong>value</strong> (<em>str</em>) &#8211; desired value of the attribute</li>
<li><strong>collection</strong> (<a class="reference internal" href="#gnome.utilities.orderedcollection.OrderedCollection" title="gnome.utilities.orderedcollection.OrderedCollection"><em>OrderedCollection</em></a>) &#8211; the ordered collection in which
to search</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.setup_model_run">
<code class="descname">setup_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.setup_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.setup_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up each mover for the model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.setup_time_step">
<code class="descname">setup_time_step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.setup_time_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.setup_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>sets up everything for the current time_step:</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.move_elements">
<code class="descname">move_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.move_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.move_elements" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Moves elements:</dt>
<dd><ul class="first last simple">
<li>loops through all the movers. and moves the elements</li>
<li>sets new_position array for each spill</li>
<li>calls the beaching code to beach the elements that need beaching.</li>
<li>sets the new position</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Weathers elements:</p>
<ul class="simple">
<li>loops through all the weatherers, passing in the spill_container
and the time range</li>
<li>a weatherer modifies the data arrays in the spill container, so a
particular time range should not be run multiple times.  It is
expected that we are processing a sequence of contiguous time ranges.</li>
<li>Note: If there are multiple sequential weathering processes, some
inaccuracy could occur.  A proposed solution is to
&#8216;super-sample&#8217; the model time step so that it will be replaced
with many smaller time steps.  We&#8217;ll have to see if this pans
out in practice.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.step_is_done">
<code class="descname">step_is_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop through movers and weatherers and call model_step_is_done</p>
<p>Remove elements that marked for removal</p>
<p>Output data</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>valid</em>, <em>messages=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.write_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gnome.model.Model.step">
<code class="descname">step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Steps the model forward (or backward) in time. Needs testing for
hind casting.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.next" title="Permalink to this definition">¶</a></dt>
<dd><p>(This method satisfies Python&#8217;s iterator and generator protocols)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the step number</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.full_run">
<code class="descname">full_run</code><span class="sig-paren">(</span><em>rewind=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.full_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.full_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a full run of the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rewind=True</strong> &#8211; whether to rewind the model first &#8211; if set to
false, model will be run from the current step to the end</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of outputter info dicts</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.spills_to_dict">
<code class="descname">spills_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.spills_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.spills_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>return the spills ordered collection for serialization</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.spills_update_from_dict">
<code class="descname">spills_update_from_dict</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.spills_update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.spills_update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke SpillContainerPair().update_from_dict</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.uncertain_spills_to_dict">
<code class="descname">uncertain_spills_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.uncertain_spills_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.uncertain_spills_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>return the uncertain_spills ordered collection for serialization/save
files</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save the model state in saveloc. If self.zipsave is True, then a
zip archive is created and model files are saved to the archive.</p>
<p>This overrides the base class save(). Model contains collections and
model must invoke save for each object in the collection. It must also
save the data in the SpillContainer&#8217;s if it is a mid-run save.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; If data is saved to zipfile (default behavior), then
this is name of zip file. For a zipfile, the model&#8217;s state is
always contained in Model.json. If zipsave is False, then model&#8217;s
json is stored in name.json</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">references</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model object
treat special-case attributes of Model.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.model.Model.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>treat special-case attributes of Model.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.model.Model.loads">
<em class="property">classmethod </em><code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc</em>, <em>references=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads a model from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>saveloc</strong> &#8211; location of data files</td>
</tr>
</tbody>
</table>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>merge &#8216;model&#8217; into self</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>invoke validate for all gnome objects contained in model
todo: should also check wind, water, waves are defined if weatherers
are defined</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.set_make_default_refs">
<code class="descname">set_make_default_refs</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.set_make_default_refs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.set_make_default_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>make default refs for all items in (&#8216;weatherers&#8217;, &#8216;movers&#8217;,
&#8216;environment&#8217;) collections</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.get_spill_property">
<code class="descname">get_spill_property</code><span class="sig-paren">(</span><em>prop_name</em>, <em>ucert=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.get_spill_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.get_spill_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to allow user to look up properties of a spill.
User can specify ucert as &#8216;ucert&#8217; or 1</p>
</dd></dl>

<dl class="method">
<dt id="gnome.model.Model.get_spill_data">
<code class="descname">get_spill_data</code><span class="sig-paren">(</span><em>target_properties</em>, <em>conditions</em>, <em>ucert=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/model.html#Model.get_spill_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.model.Model.get_spill_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to allow user to write an expression to filter
raw spill data
Example case:
get_spill_data(&#8216;position &amp;&amp; mass&#8217;,
&#8216;position &gt; 50 &amp;&amp; spill_num == 1 || status_codes == 1&#8217;)</p>
<p>WARNING: EXPENSIVE! USE AT YOUR OWN RISK ON LARGE num_elements!</p>
<p>Example spill element properties are below. This list may not contain
all properties tracked by the model.
&#8216;positions&#8217;, &#8216;next_positions&#8217;, &#8216;last_water_positions&#8217;, &#8216;status_codes&#8217;,
&#8216;spill_num&#8217;, &#8216;id&#8217;, &#8216;mass&#8217;, &#8216;age&#8217;</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.map">
<span id="gnome-map-the-pygnome-map-class"></span><h2><code class="docutils literal"><span class="pre">gnome.map</span></code> &#8211; the PyGnome map class<a class="headerlink" href="#module-gnome.map" title="Permalink to this headline">¶</a></h2>
<p>An implementation of the GNOME land-water map.</p>
<p>This is a re-write of the C++ raster map approach</p>
<dl class="docutils">
<dt>Features:</dt>
<dd><ul class="first last simple">
<li>Map now handles spillable area and map bounds as polygons</li>
<li>raster is the same aspect ratio as the land</li>
<li>internally, raster is a numpy array</li>
<li>land raster is only as big as the land &#8211; if the map bounds are bigger,
extra space is not in the land map</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="gnome.map.GnomeMap">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">GnomeMap</code><span class="sig-paren">(</span><em>map_bounds=None</em>, <em>spillable_area=None</em>, <em>land_polys=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap" title="Permalink to this definition">¶</a></dt>
<dd><p>The very simplest map for GNOME &#8211; all water
with only a bounding box for the map bounds.</p>
<p>This also serves as a description of the interface</p>
<p>This __init__ will be different for other implementations</p>
<p>Optional parameters (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger
or smaller than the land raster</li>
<li><strong>spillable_area</strong> (<em>Either a PolygonSet object or a list of lists
from which a polygon set can be created. Each element in the list
is a list of points defining a polygon.</em>) &#8211; The PolygonSet bounding the spillable_area.</li>
<li><strong>land_polys</strong> (<em>Either a PolygonSet object or a list of lists
from which a polygon set can be created. Each element in the list
is a list of points defining a polygon.</em>) &#8211; The PolygonSet holding the land polygons</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note on &#8216;map_bounds&#8217;:</dt>
<dd>( (x1,y1), (x2,y2),(x3,y3),..)
An NX2 array of points that describe a polygon
if no map bounds is provided &#8211; the whole world is valid</dd>
</dl>
<dl class="method">
<dt id="gnome.map.GnomeMap.map_bounds_to_dict">
<code class="descname">map_bounds_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.map_bounds_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.map_bounds_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert numpy array to a list for serializing</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.map_bounds_update_from_dict">
<code class="descname">map_bounds_update_from_dict</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.map_bounds_update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.map_bounds_update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list of tuples back to numpy array</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.spillable_area_to_dict">
<code class="descname">spillable_area_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.spillable_area_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.spillable_area_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert numpy array to a list for serializing</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.spillable_area_update_from_dict">
<code class="descname">spillable_area_update_from_dict</code><span class="sig-paren">(</span><em>poly_set</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.spillable_area_update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.spillable_area_update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list of tuples back to numpy array</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.on_map">
<code class="descname">on_map</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.on_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.on_map" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>3-tuple of floats: (long, lat, depth) or a
NX3 numpy array</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">bool array: True if the location is on the map,
False otherwise</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Note:</dt>
<dd>coord is 3-d, but the concept of &#8220;on the map&#8221; is 2-d in this context,
so depth is ignored.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.on_land">
<code class="descname">on_land</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.on_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.on_land" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats: (long, lat, depth)</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>Always returns False&#8211; no land in this implementation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.in_water">
<code class="descname">in_water</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.in_water"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.in_water" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>3-tuple of floats: (long, lat, depth)
or an Nx3 array</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>True if the point is in the water,</li>
<li>False if the point is on land (or off map?)</li>
</ul>
<p>This implementation has no land, so always True in on the map.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.allowable_spill_position">
<code class="descname">allowable_spill_position</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.allowable_spill_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.allowable_spill_position" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats: (long, lat, depth)</em>) &#8211; location for test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>True if the point is an allowable spill position</li>
<li>False if the point is not an allowable spill position</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it could be either off the map, or in a location that
spills aren&#8217;t allowed</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.beach_elements">
<code class="descname">beach_elements</code><span class="sig-paren">(</span><em>spill</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.beach_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.beach_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines which LEs were or weren&#8217;t beached or moved off_map.
status_code is changed to oil_status.off_maps if off the map.</p>
<p>Called by the model in the main time loop, after all movers have acted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<p>This map class has no land, so only the map check and
resurface_airborn elements is done: noting else changes.</p>
<p>subclasses that override this probably want to make sure that:</p>
<p>self.resurface_airborne_elements(spill)
self._set_off_map_status(spill)</p>
<p>are called.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.refloat_elements">
<code class="descname">refloat_elements</code><span class="sig-paren">(</span><em>spill_container</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.refloat_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.refloat_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs the re-float logic &#8211; changing the element
status flag, and moving the element to the last known water position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This map class has no land, and so is a no-op.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.GnomeMap.resurface_airborne_elements">
<code class="descname">resurface_airborne_elements</code><span class="sig-paren">(</span><em>spill_container</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#GnomeMap.resurface_airborne_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.GnomeMap.resurface_airborne_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes any elements that are left above the water surface (z &lt; 0.0)
and puts them on the surface (z == 0.0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; current SpillContainer</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While this shouldn&#8217;t occur according to the physics we&#8217;re modeling,
some movers may push elements up too high, or multiple movers may
add vertical movement that adds up to over the surface. e.g rise
velocity.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.map.RasterMap">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">RasterMap</code><span class="sig-paren">(</span><em>bitmap_array</em>, <em>projection</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A land water map implemented as a raster</p>
<p>This one uses a numpy array of uint8, so there are 8 bits to choose from...</p>
<p>It requires a constant refloat half-life in hours</p>
<p>This will usually be initialized in a sub-class (from a BNA, etc)
NOTE: Nothing new added to _state attribute for serialization</p>
<p>create a new RasterMap</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bitmap_array</strong> (<em>a (W,H) numpy array of type uint8</em>) &#8211; A numpy array that stores the land-water map
0 is water. 1 is land. In theory, other values
could be used for other purposes. If the array
is not C-contiguous, it will be copied to a
C-contiguus array.</li>
<li><strong>projection</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.map_canvas.Projection</span></code>) &#8211; A Projection object &#8211; used to convert from
lat-long to pixels in the array</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>refloat_halflife</strong> (<em>float. Units are hours</em>) &#8211; The halflife for refloating off land
&#8211; assumed to be the same for all land.
0.0 means all refloat every time step
&lt; 0.0 means never re-float.</li>
<li><strong>map_bounds</strong> (<em>(N,2) numpy array of floats</em>) &#8211; The polygon bounding the map &#8211; could be larger
or smaller than the land raster</li>
<li><strong>spillable_area</strong> (<em>(N,2) numpy array of floats</em>) &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.map.RasterMap.build_coarser_bitmaps">
<code class="descname">build_coarser_bitmaps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.build_coarser_bitmaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.build_coarser_bitmaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the list which contains the different resolution raster maps.
Scale -&gt; bitmap
example for base map of 1024 x 1024:
0 -&gt; 1/16th bitmap 64 base cells per cell
1 -&gt; 1/32nd bitmap 32:1
2 -&gt; 1/64th bitmap 16:1
3 -&gt; 1/128th bitmap 8:1
4 -&gt; 1/256th bitmap 4:1
5 -&gt; 1/512th bitmap 2:1
6 -&gt; 1/1024th bitmap (== base map 1:1)</p>
<p>The general idea is that the particle position (an int) can quickly
be mapped into any scale and the path can begin from there.
For example, if your path begins offshore and ends in a narrow inlet,
your scale might begin on the 32:1 map.
But as soon as the path crosses into the (32:1) raster cell containing
the inlet (which will register as a land cell on that raster),
the scale will decrease to 4:1, when the cell is completely water.
In the end, if the scale decreases to 1:1 and there&#8217;s still a land hit,
then land was hit.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.save_as_image">
<code class="descname">save_as_image</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.save_as_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.save_as_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the land-water raster as a PNG save_as_image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the name of the file to save to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.on_land">
<code class="descname">on_land</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.on_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.on_land" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> (<em>3-tuple of floats &#8211; (long, lat, depth)</em>) &#8211; (long, lat, depth) location &#8211; depth is ignored here.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li>1 if point on land</li>
<li>0 if not on land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">to_pixel() converts to array of points...</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.in_water">
<code class="descname">in_water</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.in_water"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.in_water" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>checks if it&#8217;s on the map, first.</dt>
<dd>(depth is ignored in this version)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> &#8211; (lon, lat, depth) coordinate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">true if the point given by coord is in the water</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.beach_elements">
<code class="descname">beach_elements</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.beach_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.beach_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines which elements were or weren&#8217;t beached.</p>
<p>Any that are beached have the beached flag set, and a
&#8220;last known water position&#8221; (lkwp) is computed</p>
<p>This version uses a modified Bresenham algorithm to find out
which pixels the LE may have crossed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sc</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>
It must have the following data arrays:
(&#8216;prev_position&#8217;, &#8216;positions&#8217;, &#8216;last_water_pt&#8217;, &#8216;status_code&#8217;)) &#8211; the current spill container</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.refloat_elements">
<code class="descname">refloat_elements</code><span class="sig-paren">(</span><em>spill_container</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.refloat_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.refloat_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method performs the re-float logic &#8211; changing the element
status flag, and moving the element to the last known water position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spill_container</strong> (<code class="xref py py-class docutils literal"><span class="pre">gnome.spill_container.SpillContainer</span></code>) &#8211; the current spill container</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.allowable_spill_position">
<code class="descname">allowable_spill_position</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.allowable_spill_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.allowable_spill_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true is the spill position is in the allowable spill area</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may not be the same as in_water!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord</strong> &#8211; (lon, lat, depth) coordinate</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.map.RasterMap.to_pixel_array">
<code class="descname">to_pixel_array</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#RasterMap.to_pixel_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.RasterMap.to_pixel_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects an array of (lon, lat) tuples onto the basebitmap,
and modifies it in place to hold the corresponding projected values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> &#8211; a numpy array of (lon, lat, depth) points</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a numpy array of (x, y) pixel values</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.map.MapFromBNA">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">MapFromBNA</code><span class="sig-paren">(</span><em>filename</em>, <em>raster_size=16777216</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#MapFromBNA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.MapFromBNA" title="Permalink to this definition">¶</a></dt>
<dd><p>A raster land-water map, created from file with polygons in it.</p>
<p>Currently only support BNA, but could be shapefile, or ???</p>
<p>Creates a GnomeMap (specifically a RasterMap) from a data file.
It is expected that you will get the spillable area and map bounds
from the data file &#8211; if they exist</p>
<p>Required arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; full path to the data file</li>
<li><strong>refloat_halflife</strong> &#8211; the half-life (in hours) for the re-floating.</li>
<li><strong>raster_size</strong> (<em>integer</em>) &#8211; the total number of pixels (bytes) to make the
raster &#8211; the actual size will match the
aspect ratio of the bounding box of the land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger or
smaller than the land raster</li>
<li><strong>spillable_area</strong> &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gnome.map.MapFromUGrid">
<em class="property">class </em><code class="descclassname">gnome.map.</code><code class="descname">MapFromUGrid</code><span class="sig-paren">(</span><em>filename</em>, <em>raster_size=1048576</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#MapFromUGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.MapFromUGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>A raster land-water map, created from netcdf File of a UGrid</p>
<p>Creates a GnomeMap (specifically a RasterMap) from a netcdf
data file with a traingular mesh grid in it.
The spillable area and map bounds need to be supplied &#8211; there is
currenty no way to exprtes that in a netcdf file.</p>
<p>Required arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; full path to the data file</li>
<li><strong>refloat_halflife</strong> &#8211; the half-life (in hours) for the re-floating.</li>
<li><strong>raster_size</strong> (<em>integer</em>) &#8211; the total number of pixels (bytes) to make the
raster &#8211; the actual size will match the
aspect ratio of the bounding box of the land</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_bounds</strong> &#8211; The polygon bounding the map &#8211; could be larger or
smaller than the land raster</li>
<li><strong>spillable_area</strong> &#8211; The polygon bounding the spillable_area</li>
<li><strong>id</strong> (<em>string</em>) &#8211; unique ID of the object. Using UUID as a string.
This is only used when loading object from save file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.map_from_rectangular_grid">
<code class="descclassname">gnome.map.</code><code class="descname">map_from_rectangular_grid</code><span class="sig-paren">(</span><em>mask</em>, <em>lon</em>, <em>lat</em>, <em>refine=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#map_from_rectangular_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.map_from_rectangular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Suitable for a rectangular, but not fully regular, grid</p>
<p>Such that it can be described by single longitude and latitude vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mask</strong> &#8211; the land-water mask as a numpy array</li>
<li><strong>lon</strong> &#8211; longitude array</li>
<li><strong>lon</strong> &#8211; latitude array</li>
<li><strong>refine=1</strong> &#8211; amount to refine grid &#8211; 4 will give 4 times the
resolution</li>
<li><strong>kwargs</strong> &#8211; Other keyword arguments are passed on to RasterMap</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.grid_from_nc">
<code class="descclassname">gnome.map.</code><code class="descname">grid_from_nc</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#grid_from_nc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.grid_from_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>generates a grid_mask and lat lon from a conforming netcdf file</p>
</dd></dl>

<dl class="function">
<dt id="gnome.map.map_from_rectangular_grid_nc_file">
<code class="descclassname">gnome.map.</code><code class="descname">map_from_rectangular_grid_nc_file</code><span class="sig-paren">(</span><em>filename</em>, <em>refine=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#map_from_rectangular_grid_nc_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.map_from_rectangular_grid_nc_file" title="Permalink to this definition">¶</a></dt>
<dd><p>builds a raster map from a rectangular grid in a netcdf file</p>
<p>only tested with the HYCOM grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; the full path or opendap url for the netcdf file</li>
<li><strong>refine</strong> (<em>integer</em>) &#8211; how much to refine the grid. 1 means keep it as it is,
otherwise is will scale</li>
<li><strong>kwargs</strong> &#8211; other key word arguemnts &#8211; passed on to RasterMap class
constructor</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.refine_axis">
<code class="descclassname">gnome.map.</code><code class="descname">refine_axis</code><span class="sig-paren">(</span><em>old_axis</em>, <em>refine</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#refine_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.refine_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>refines the axis be interpolating points between each axis points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>old_axis</strong> (<em>1-d numpy array of floats</em>) &#8211; the axis values</li>
<li><strong>refine</strong> (<em>integer</em>) &#8211; amount to refine grid &#8211; 4 will give 4 times the resolution</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.map.map_from_regular_grid">
<code class="descclassname">gnome.map.</code><code class="descname">map_from_regular_grid</code><span class="sig-paren">(</span><em>grid_mask</em>, <em>lon</em>, <em>lat</em>, <em>refine=4</em>, <em>refloat_halflife=1</em>, <em>map_bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/map.html#map_from_regular_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.map.map_from_regular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>note: poorly tested &#8211; here to save it in case we need it in the future</p>
<p>makes a raster map from a regular grid: i.e delta_lon and delta-lat are
constant.</p>
</dd></dl>

</div>
<div class="section" id="module-gnome.spill">
<span id="gnome-spill-classes-in-the-spill-module"></span><h2><code class="docutils literal"><span class="pre">gnome.spill</span></code> &#8211; classes in the spill module<a class="headerlink" href="#module-gnome.spill" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.spill.Spill">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">Spill</code><span class="sig-paren">(</span><em>release</em>, <em>element_type=None</em>, <em>substance=None</em>, <em>on=True</em>, <em>amount=None</em>, <em>units=None</em>, <em>amount_uncertainty_scale=0.0</em>, <em>name='Spill'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill" title="Permalink to this definition">¶</a></dt>
<dd><p>Models a spill</p>
<p>Spills used by the gnome model. It contains a release object, which
releases elements. It also contains an element_type object which
contains the type of substance spilled and it initializes data arrays
to non-default values (non-zero).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>release</strong> (derived from <a class="reference internal" href="#gnome.spill.Release" title="gnome.spill.Release"><code class="xref py py-class docutils literal"><span class="pre">Release</span></code></a>) &#8211; an object defining how elements are to be released</td>
</tr>
</tbody>
</table>
<p><strong>Optional parameters (kwargs):</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>element_type</strong> (<a class="reference internal" href="#gnome.spill.elements.element_type.ElementType" title="gnome.spill.elements.element_type.ElementType"><code class="xref py py-class docutils literal"><span class="pre">ElementType</span></code></a>) &#8211; ElementType object defining the type
of elements that are released. These are spill specific properties
of the elements.</li>
<li><strong>on=True</strong> (<em>bool</em>) &#8211; Toggles the spill on/off.</li>
<li><strong>amount=None</strong> (<em>float</em>) &#8211; mass or volume of oil spilled.</li>
<li><strong>units=None</strong> (<em>str</em>) &#8211; must provide units for amount spilled.</li>
<li><strong>amount_uncertainty_scale=0.0</strong> (<em>float</em>) &#8211; scale value in range 0-1
that adds uncertainty to the
spill amount.
Maximum uncertainty scale
is (2/3) * spill_amount.</li>
<li><strong>name='Spill'</strong> (<em>str</em>) &#8211; a name for the spill.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Define either volume or mass in &#8216;amount&#8217; attribute and provide
appropriate &#8216;units&#8217;. Defines default element_type as floating
elements with mass if the Spill&#8217;s &#8216;amount&#8217; property is not None.
If amount property is None, then just floating elements
(ie. &#8216;windages&#8217;)</p>
</div>
<dl class="attribute">
<dt id="gnome.spill.Spill.amount_uncertainty_scale">
<code class="descname">amount_uncertainty_scale</code><em class="property"> = None</em><a class="headerlink" href="#gnome.spill.Spill.amount_uncertainty_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>fraction of area covered by oil</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.Spill.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>prop</em>, <em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set" title="Permalink to this definition">¶</a></dt>
<dd><p>sets an existing property. The property could be of one of the
contained objects like &#8216;Release&#8217; or &#8216;ElementType&#8217;
It can also be a property of one of the initializers contained in
the &#8216;ElementType&#8217; object.</p>
<p>If the property doesn&#8217;t exist for any of these, then an error is raised
since user cannot set a property that does not exist using this method</p>
<p>For example: set(&#8216;windage_range&#8217;, (0.4, 0.4)) sets the windage_range
assuming the element_type is floating</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">There is an issue in that if two initializers have the same
property - could be the case if they both define a &#8216;distribution&#8217;,
then it does not know which one to return</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>prop=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get" title="Permalink to this definition">¶</a></dt>
<dd><p>for get(), return all properties of embedded release object and
element_type initializer objects. If &#8216;prop&#8217; is not None, then return
the property</p>
<p>For example: get(&#8216;windage_range&#8217;) returns the &#8216;windage_range&#8217; assuming
the element_type = floating()</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">There is an issue in that if two initializers have the same
property - could be the case if they both define a &#8216;distribution&#8217;,
then it does not know which one to return</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get_initializer_by_name">
<code class="descname">get_initializer_by_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get_initializer_by_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_initializer_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get first initializer in list whose name matches &#8216;name&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.has_initializer">
<code class="descname">has_initializer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.has_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.has_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if an initializer is present in the list which sets the
data_array corresponding with &#8216;name&#8217;, otherwise returns False</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get_initializer">
<code class="descname">get_initializer</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>If name is None, return list of all initializers else return
initializer that sets given &#8216;name&#8217;.
&#8216;name&#8217; refers to the data_array initialized by initializer.
For instance, if name=&#8217;rise_vel&#8217;, function will look in all
initializers to find the one whose array_types contain &#8216;rise_vel&#8217;.</p>
<p>If multiple initializers set &#8216;name&#8217;, then return the first one in the
list. Although nothing prevents the user from having two initializers
for the same data_array, it doesn&#8217;t make much sense.</p>
<p>The default &#8216;name&#8217; of an initializer is the data_array that a mover
requires and that the initializer is setting. For instance,</p>
<blockquote>
<div>init = InitRiseVelFromDist()
init.name is &#8216;rise_vel&#8217; by default</div></blockquote>
<p>is an initializer that sets the &#8216;rise_vel&#8217; if a RiseVelocityMover is
included in the Model. User can change the name of the initializer</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_initializer">
<code class="descname">set_initializer</code><span class="sig-paren">(</span><em>init</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>set/add given initializer. Function looks for first initializer in list
with same array_types and replaces it if found else it appends this to
list of initializers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">nothing prevents user from defining two initializers that
set the same data_arrays; however, there isn&#8217;t a use case for it</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.del_initializer">
<code class="descname">del_initializer</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.del_initializer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.del_initializer" title="Permalink to this definition">¶</a></dt>
<dd><p>delete the initializer with given &#8216;name&#8217;</p>
<p>The default &#8216;name&#8217; of an initializer is the data_array that a mover
requires and that the initializer is setting. For instance,
the following is an initializer that sets the &#8216;rise_vel&#8217; if a
RiseVelocityMover is included in the Model.</p>
<blockquote>
<div>init = InitRiseVelFromDist()
init.name is &#8216;rise_vel&#8217; by default</div></blockquote>
<p>If name = &#8216;rise_vel&#8217;, all initializers with this name will be deleted</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.units">
<code class="descname">units</code><a class="headerlink" href="#gnome.spill.Spill.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Default units in which amount of oil spilled was entered by user.
The &#8216;amount&#8217; property is returned in these &#8216;units&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>units=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.get_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mass released during the spill.
User can also specify desired output units in the function.
If units are not specified, then return in &#8216;SI&#8217; units (&#8216;kg&#8217;)
If volume is given, then use density to find mass. Density is always
at 15degC, consistent with API definition</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.uncertain_copy">
<code class="descname">uncertain_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.uncertain_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.uncertain_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deepcopy of this spill for the uncertainty runs</p>
<p>The copy has everything the same, including the spill_num,
but it is a new object with a new id.</p>
<p>Not much to this method, but it could be overridden to do something
fancier in the future or a subclass.</p>
<p>There are a number of python objects that cannot be deepcopied.
- Logger objects</p>
<p>So we copy them temporarily to local variables before we deepcopy
our Spill object.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_amount_uncertainty">
<code class="descname">set_amount_uncertainty</code><span class="sig-paren">(</span><em>up_or_down=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set_amount_uncertainty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_amount_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shifts the spill amount based on a scale value
in the range [0.0 ... 1.0].  The maximum uncertainty scale value
is (2/3) * spill_amount.
We determine either an upper uncertainty or a lower uncertainty
multiplier.  Then we shift our spill amount value based on it.</p>
<p>Since we are irreversibly changing the spill amount value,
we should probably do this only once.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the release to original status (before anything has been
released).</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step</p>
<p>It invokes the num_elements_to_release method for the the unerlying
release object: self.release.num_elements_to_release()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>int</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.set_newparticle_values">
<code class="descname">set_newparticle_values</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.set_newparticle_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.set_newparticle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>SpillContainer will release elements and initialize all data_arrays
to default initial value. The SpillContainer gets passed as input and
the data_arrays for &#8216;position&#8217; get initialized correctly by the release
object: self.release.set_newparticle_positions()</p>
<p>If a Spill Amount is given, the Spill object also sets the &#8216;mass&#8217; data
array; else &#8216;mass&#8217; array remains &#8216;0&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_new_particles</strong> (<em>int</em>) &#8211; number of new particles that were added.
Always greater than 0</li>
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
<li><strong>data_arrays</strong> (<em>dict containing numpy arrays for values</em>) &#8211; dict of data_arrays provided by the SpillContainer.
Look for &#8216;positions&#8217; array in the dict and update positions for
latest num_new_particles that are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Also, the set_newparticle_values() method for all element_type gets
called so each element_type sets the values for its own data correctly</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>override base serialize implementation
Need to add node for release object and element_type object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.spill.Spill.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/spill.html#Spill.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Spill.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of creating schema dynamically for Spill() before
deserialization, call nested object&#8217;s serialize/deserialize methods</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.Spill.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Spill.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.Spill.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Spill.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.Spill.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.Release">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">Release</code><span class="sig-paren">(</span><em>release_time</em>, <em>num_elements=0</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release" title="Permalink to this definition">¶</a></dt>
<dd><p>base class for Release classes.</p>
<p>It contains interface for Release objects</p>
<dl class="method">
<dt id="gnome.spill.Release.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step. Base class has partial (incomplete)
implementation.</p>
<p>This base class method checks if current_time in first step
is valid and toggles the self.start_time_invalid flag if it is valid.
If current_time &lt;= self.release_time the first time this is called,
then toggle start_time_invalid to True.</p>
<p>Subclasses should define the complete implementation and return number
of new particles to be released once this check passes. Be sure to call
the base class method first if start_time_invalid flag should be
checked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
<p>self.num_released is updated after self.set_newparticle_values is
called. Particles are considered released after the values are set.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Release.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>derived object should set the &#8216;positions&#8217; array for the data_arrays
base class has no implementation</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Release.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Release to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original _state.
Subclasses should overload for additional functions required to reset
_state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.Release.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#Release.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.Release.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.Release.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.Release.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a timedelta object defining the time over which the particles
are released. The default is 0; derived classes like PointLineRelease
must over-ride</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.PointLineRelease">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">PointLineRelease</code><span class="sig-paren">(</span><em>release_time</em>, <em>start_position</em>, <em>num_elements=None</em>, <em>num_per_timestep=None</em>, <em>end_release_time=None</em>, <em>end_position=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#PointLineRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>The primary spill source class  &#8211;  a release of floating
non-weathering particles, can be instantaneous or continuous, and be
released at a single point, or over a line.</p>
<p>Required Arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released (datetime object)</li>
<li><strong>start_position</strong> (<em>3-tuple of floats (long, lat, z)</em>) &#8211; initial location the elements are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Either num_elements or num_per_timestep must be given. If
both are None, then it defaults to num_elements=1000. If both are
given a TypeError is raised because user can only specify one or
the other, not both.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_elements</strong> (<em>integer</em>) &#8211; total number of elements to be released</li>
<li><strong>num_per_timestep</strong> &#8211; fixed number of LEs released at each timestep</li>
<li><strong>end_release_time=None</strong> &#8211; optional &#8211; for a time varying release,
the end release time. If None, then release is instantaneous</li>
<li><strong>end_position=None</strong> &#8211; optional. For moving source, the end position
If None, then release from a point source</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>num_elements and release_time passed to base class __init__ using super
See base <a class="reference internal" href="#gnome.spill.Release" title="gnome.spill.Release"><code class="xref py py-class docutils literal"><span class="pre">Release</span></code></a> documentation</p>
<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.is_pointsource">
<code class="descname">is_pointsource</code><a class="headerlink" href="#gnome.spill.PointLineRelease.is_pointsource" title="Permalink to this definition">¶</a></dt>
<dd><p>if end_position - start_position == 0, point source
otherwise it is a line source</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if point source, false otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.PointLineRelease.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>duration over which particles are released in seconds</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#PointLineRelease.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineRelease.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>sets positions for newly released particles. It evenly spaces the
particles using numpy.linespace. Set (start_postion, end_position)
depending on whether it is a point source, a line release
an instantaneous release or a time varying release.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#PointLineRelease.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.PointLineRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewind to initial conditions &#8211; i.e. nothing released.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.PointLineRelease.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.PointLineRelease.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.PointLineRelease.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.PointLineRelease.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the number of elements to be released during:
current_time + time_step. Base class has partial (incomplete)
implementation.</p>
<p>This base class method checks if current_time in first step
is valid and toggles the self.start_time_invalid flag if it is valid.
If current_time &lt;= self.release_time the first time this is called,
then toggle start_time_invalid to True.</p>
<p>Subclasses should define the complete implementation and return number
of new particles to be released once this check passes. Be sure to call
the base class method first if start_time_invalid flag should be
checked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>current_time</strong> (<em>datetime.datetime</em>) &#8211; current time</li>
<li><strong>time_step</strong> (<em>integer seconds</em>) &#8211; the time step, sometimes used to decide how many
should get released.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of elements that will be released. This is taken
by SpillContainer to initialize all data_arrays.</p>
</td>
</tr>
</tbody>
</table>
<p>self.num_released is updated after self.set_newparticle_values is
called. Particles are considered released after the values are set.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.PointLineRelease.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.PointLineRelease.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.SpatialRelease">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">SpatialRelease</code><span class="sig-paren">(</span><em>release_time</em>, <em>start_position</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple release class  &#8211;  a release of floating non-weathering particles,
with their initial positions pre-specified</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released</li>
<li><strong>start_positions</strong> (<em>(num_elements, 3) numpy array of float64
&#8211; (long, lat, z)</em>) &#8211; locations the LEs are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>num_elements and release_time passed to base class __init__ using super
See base <a class="reference internal" href="#gnome.spill.Release" title="gnome.spill.Release"><code class="xref py py-class docutils literal"><span class="pre">Release</span></code></a> documentation</p>
<dl class="classmethod">
<dt id="gnome.spill.SpatialRelease.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom new_from_dict() functionality for SpatialRelease</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of particles released in current_time + time_step</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#SpatialRelease.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.SpatialRelease.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>set positions for new elements added by the SpillContainer</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this releases all the elements at their initial positions at
the release_time</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.SpatialRelease.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.SpatialRelease.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.SpatialRelease.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.SpatialRelease.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.SpatialRelease.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a timedelta object defining the time over which the particles
are released. The default is 0; derived classes like PointLineRelease
must over-ride</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Release to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original _state.
Subclasses should overload for additional functions required to reset
_state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.SpatialRelease.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.SpatialRelease.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.spill.VerticalPlumeRelease">
<em class="property">class </em><code class="descclassname">gnome.spill.</code><code class="descname">VerticalPlumeRelease</code><span class="sig-paren">(</span><em>release_time</em>, <em>num_elements</em>, <em>start_position</em>, <em>plume_data</em>, <em>end_release_time</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#VerticalPlumeRelease"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease" title="Permalink to this definition">¶</a></dt>
<dd><p>An Underwater Plume spill class &#8211; a continuous release of particles,
controlled by a contained spill generator object.
- plume model generator will have an iteration method.  This will provide
flexible looping and list comprehension behavior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_elements</strong> (<em>integer</em>) &#8211; total number of elements to be released</li>
<li><strong>start_position</strong> (<em>3-tuple of floats (long, lat, z)</em>) &#8211; initial location the elements are released</li>
<li><strong>release_time</strong> (<em>datetime.datetime</em>) &#8211; time the LEs are released</li>
<li><strong>start_positions</strong> (<em>(num_elements, 3) numpy array of float64
&#8211; (long, lat, z)</em>) &#8211; locations the LEs are released</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.num_elements_to_release">
<code class="descname">num_elements_to_release</code><span class="sig-paren">(</span><em>current_time</em>, <em>time_step</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#VerticalPlumeRelease.num_elements_to_release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.num_elements_to_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of particles released in current_time + time_step</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.set_newparticle_positions">
<code class="descname">set_newparticle_positions</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>current_time</em>, <em>time_step</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/release.html#VerticalPlumeRelease.set_newparticle_positions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.set_newparticle_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set positions for new elements added by the SpillContainer</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.VerticalPlumeRelease.release_duration">
<code class="descname">release_duration</code><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.release_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a timedelta object defining the time over which the particles
are released. The default is 0; derived classes like PointLineRelease
must over-ride</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>rewinds the Release to original status (before anything has been
released).</p>
<p>Base class sets &#8216;num_released&#8217;=0 and &#8216;start_time_invalid&#8217;=True
properties to original _state.
Subclasses should overload for additional functions required to reset
_state.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>define schema based on type of desired output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.VerticalPlumeRelease.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.VerticalPlumeRelease.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.spill.elements.element_type">
<span id="gnome-spill-elements-classes-in-the-elements-module"></span><h2><code class="docutils literal"><span class="pre">gnome.spill.elements</span></code> &#8211; classes in the elements module<a class="headerlink" href="#module-gnome.spill.elements.element_type" title="Permalink to this headline">¶</a></h2>
<p>Types of elements that a spill can expect
These are properties that are spill specific like:</p>
<blockquote>
<div>&#8216;floating&#8217; element_types would contain windage_range, windage_persist
&#8216;subsurface_dist&#8217; element_types would contain rise velocity distribution info
&#8216;nonweathering&#8217; element_types would set use_droplet_size flag to False
&#8216;weathering&#8217; element_types would use droplet_size, densities, mass?</div></blockquote>
<dl class="class">
<dt id="gnome.spill.elements.element_type.ElementType">
<em class="property">class </em><code class="descclassname">gnome.spill.elements.element_type.</code><code class="descname">ElementType</code><span class="sig-paren">(</span><em>initializers=[]</em>, <em>substance=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType" title="Permalink to this definition">¶</a></dt>
<dd><p>Define initializers for the type of elements.
The default element_type has a substance with density of water
(1000 kg/m^3). This is labeled as &#8216;oil_conservaitve&#8217;, same as in
original gnome. This is currently one of the mock (&#8220;fake&#8221;) oil objects,
used primarily to help integrate weathering processes. It doesn&#8217;t mean
weathering is off - if there are no weatherers, then oil doesn&#8217;t
weather.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initializers</strong> (<em>iterbale</em>) &#8211; a list/tuple of initializer classes used
to initialize these data arrays upon release. If this is not an
iterable, then just append &#8216;initializer&#8217; to list of initializers
assuming it is just a single initializer object</li>
<li><strong>substance=None</strong> &#8211; Type of oil spilled. If this is a
string, then use get_oil_props to get the OilProps object, else
assume it is an OilProps object. If it is None, then assume there
is no weathering.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.substance_to_dict">
<code class="descname">substance_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.substance_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.substance_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the tojson() method on substance</p>
<p>An Oil object that has been queried from the database
contains a lot of unnecessary relationships that we do not
want to represent in our JSON output,</p>
<p>So we prune them by first constructing an Oil object from the
JSON payload of the queried Oil object.</p>
<p>This creates an Oil object in memory that does not have any
database links. Then output the JSON from the unlinked object.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.array_types">
<code class="descname">array_types</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.array_types" title="Permalink to this definition">¶</a></dt>
<dd><p>compile/return dict of array_types set by all initializers contained
by ElementType object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.set_newparticle_values">
<code class="descname">set_newparticle_values</code><span class="sig-paren">(</span><em>num_new_particles</em>, <em>spill</em>, <em>data_arrays</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.set_newparticle_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.set_newparticle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>call all initializers. This will set the initial values for all
data_arrays.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>call the to_dict method on each object in the initializers dict. Store
results in dict and return.</p>
<p>todo: the standard to_dict doesn&#8217;t seem to fit well in this case. It
works but perhaps can/should be revisited to make it simpler</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.initializers_to_dict">
<code class="descname">initializers_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.initializers_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.initializers_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>just return the initializers</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize each object in &#8216;initializers&#8217; dict, then add it to the json
for the ElementType object.</p>
<p>Note: the to_dict() method returns a dict of initializers as well;
however, the schemas associated with the initializers are dynamic
(eg initializers that contain a distribution). It is easier to call the
initializer&#8217;s serialize() method instead of adding the initializer&#8217;s
schemas to the ElementType schema since they are not known ahead of
time.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.spill.elements.element_type.ElementType.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#ElementType.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>deserialize each object in the &#8216;initializers&#8217; dict, then add it to
deserialized ElementType dict</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.spill.elements.element_type.ElementType.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.spill.elements.element_type.ElementType.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.spill.elements.element_type.ElementType.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="gnome.spill.elements.element_type.floating">
<code class="descclassname">gnome.spill.elements.element_type.</code><code class="descname">floating</code><span class="sig-paren">(</span><em>windage_range=(0.01</em>, <em>0.04)</em>, <em>windage_persist=900</em>, <em>substance=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#floating"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function returns an ElementType object containing following
initializers:</p>
<p>1. InitWindages(): for initializing &#8216;windages&#8217; with user specified
windage_range and windage_persist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>substance='oil_conservative'</strong> &#8211; Type of oil spilled. Passed onto
ElementType constructor</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gnome.spill.elements.element_type.plume">
<code class="descclassname">gnome.spill.elements.element_type.</code><code class="descname">plume</code><span class="sig-paren">(</span><em>distribution_type='droplet_size'</em>, <em>distribution=None</em>, <em>windage_range=(0.01</em>, <em>0.04)</em>, <em>windage_persist=900</em>, <em>substance_name=None</em>, <em>density=None</em>, <em>density_units='kg/m^3'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/spill/elements/element_type.html#plume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.spill.elements.element_type.plume" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Helper function returns an ElementType object containing &#8216;rise_vel&#8217;
and &#8216;windages&#8217; initialized with user specified parameters for distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param str distribution_type:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt>default is &#8216;droplet_size&#8217; available options:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>&#8216;droplet_size&#8217;: Droplet size is samples from the specified</dt>
<dd><p class="first last">distribution. Rise velocity is calculated.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;rise_velocity&#8217;: rise velocity is directly sampled from the specified</dt>
<dd><p class="first last">distribution. No droplet size is computed.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param distribution=None:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">An object capable of generating a probability
distribution.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">type gnome.utilities.distributions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt>Right now, we have:</dt>
<dd><ul class="first last simple">
<li>UniformDistribution</li>
<li>NormalDistribution</li>
<li>LogNormalDistribution</li>
<li>WeibullDistribution</li>
</ul>
</dd>
</dl>
<p>New distribution classes could be made.  The only
requirement is they need to have a set_values()
method which accepts a NumPy array.
(presumably, this function will also modify
the array in some way)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param windage_range=(.01, .04):</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param windage_persist=900:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="docutils">
<dt>#    :param substance_name=&#8217;oil_conservative&#8217;:</dt>
<dd><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param substance_name=None:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param float density = None:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param str density_units=&#8217;kg/m^3&#8217;:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">substance_name or density must be provided</p>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-gnome.movers">
<span id="gnome-movers-pygnome-mover-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.movers</span></code> &#8211; PyGnome mover classes<a class="headerlink" href="#module-gnome.movers" title="Permalink to this headline">¶</a></h2>
<p>__init__.py for the gnome package</p>
<dl class="class">
<dt id="gnome.movers.Process">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">Process</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class from which all Python movers/weatherers can inherit</p>
<p>It defines the base functionality for mover/weatherer.</p>
<p>NOTE: Since base class is not Serializable, it does not need
a class level _schema attribute.</p>
<p>Initialize default Mover/Weatherer parameters</p>
<p>All parameters are optional (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>on</strong> &#8211; boolean as to whether the object is on or not. Default is on</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.movers.Process.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Process.datetime_to_seconds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Process.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Process.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Process.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Process.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived mover class needs to perform any
actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Process.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Process.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Process.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>sets active flag based on time_span and on flag.
Object is active if following hold and &#8216;on&#8217; is True:</p>
<ol class="arabic simple">
<li>active_start &lt;= (model_time + time_step/2) so object is on for
more than half the timestep</li>
<li>(model_time + time_step/2) &lt;= active_stop so again the object is
on for at least half the time step
flag to true.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.Process.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Process.model_step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Process.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.Mover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">Mover</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Mover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Mover" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize default Mover/Weatherer parameters</p>
<p>All parameters are optional (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>on</strong> &#8211; boolean as to whether the object is on or not. Default is on</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.movers.Mover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#Mover.get_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.Mover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the move in (long,lat,z) space. It returns the delta move
for each element of the spill as a numpy array of size
(number_elements X 3) and dtype = gnome.basic_types.world_point_type</p>
<p>Base class returns an array of numpy.nan for delta to indicate the
get_move is not implemented yet.</p>
<p>Each class derived from Mover object must implement it&#8217;s own get_move</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>All movers must implement get_move() since that&#8217;s what the model calls</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.CyMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">CyMover</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for python wrappers around cython movers.
Uses super(CyMover,self).__init__(**kwargs) to call Mover class
__init__ method</p>
<p>All cython movers (CyWindMover, CyRandomMover) are instantiated by a
derived class, and then contained by this class in the member &#8216;movers&#8217;.
They will need to extract info from spill object.</p>
<p>We assumes any derived class will instantiate a &#8216;mover&#8217; object that
has methods like: prepare_for_model_run, prepare_for_model_step,</p>
<p>All kwargs passed on to super class</p>
<dl class="method">
<dt id="gnome.movers.CyMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.get_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.prepare_data_for_get_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.CyMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/movers.html#CyMover.model_step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.CyMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.RandomMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">RandomMover</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/random_movers.html#RandomMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.RandomMover" title="Permalink to this definition">¶</a></dt>
<dd><p>This mover class inherits from CyMover and contains CyRandomMover</p>
<p>The real work is done by CyRandomMover.
CyMover sets everything up that is common to all movers.</p>
<p>Uses super to invoke base class __init__ method.</p>
<p>Optional parameters (kwargs)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>diffusion_coef</strong> &#8211; Diffusion coefficient for random diffusion.
Default is 100,000 cm2/sec</li>
<li><strong>uncertain_factor</strong> &#8211; Uncertainty factor. Default is 2</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto <a class="reference internal" href="#gnome.movers.Mover" title="gnome.movers.Mover"><code class="xref py py-class docutils literal"><span class="pre">gnome.movers.Mover</span></code></a> __init__
using super.  See Mover documentation for remaining valid kwargs.</p>
<dl class="method">
<dt id="gnome.movers.RandomMover.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.RandomMover.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.movers.RandomMover.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.RandomMover.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.movers.RandomMover.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.RandomMover.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.movers.RandomMover.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> &#8211; tells object whether serialization is for web content
or for generating a save file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.RandomMover.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.RandomMover.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.GridCurrentMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">GridCurrentMover</code><span class="sig-paren">(</span><em>filename</em>, <em>topology_file=None</em>, <em>extrapolate=False</em>, <em>time_offset=0</em>, <em>current_scale=1</em>, <em>uncertain_along=0.5</em>, <em>uncertain_across=0.25</em>, <em>num_method=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a GridCurrentMover</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; absolute or relative path to the data file:
could be netcdf or filelist</li>
<li><strong>topology_file=None</strong> &#8211; absolute or relative path to topology file.
If not given, the GridCurrentMover will
compute the topology from the data file.</li>
<li><strong>active_start</strong> &#8211; datetime when the mover should be active</li>
<li><strong>active_stop</strong> &#8211; datetime after which the mover should be inactive</li>
<li><strong>current_scale</strong> &#8211; Value to scale current data</li>
<li><strong>uncertain_duration</strong> &#8211; how often does a given uncertain element
get reset</li>
<li><strong>uncertain_time_delay</strong> &#8211; when does the uncertainly kick in.</li>
<li><strong>uncertain_cross</strong> &#8211; Scale for uncertainty perpendicular to the flow</li>
<li><strong>uncertain_along</strong> &#8211; Scale for uncertainty parallel to the flow</li>
<li><strong>extrapolate</strong> &#8211; Allow current data to be extrapolated
before and after file data</li>
<li><strong>time_offset</strong> &#8211; Time zone shift if data is in GMT</li>
<li><strong>num_method</strong> &#8211; Numerical method for calculating movement delta.
Default Euler
option: Runga-Kutta 4 (RK4)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>uses super, super(GridCurrentMover,self).__init__(**kwargs)</p>
<dl class="attribute">
<dt id="gnome.movers.GridCurrentMover.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.movers.GridCurrentMover.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_grid_data">
<code class="descname">get_grid_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.get_grid_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_grid_data" title="Permalink to this definition">¶</a></dt>
<dd><p>The main function for getting grid data from the mover</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_scaled_velocities">
<code class="descname">get_scaled_velocities</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.get_scaled_velocities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_scaled_velocities" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>model_time=0</strong> &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.export_topology">
<code class="descname">export_topology</code><span class="sig-paren">(</span><em>topology_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.export_topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.export_topology" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topology_file=None</strong> &#8211; absolute or relative path where
topology file will be written.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.extrapolate_in_time">
<code class="descname">extrapolate_in_time</code><span class="sig-paren">(</span><em>extrapolate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.extrapolate_in_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.extrapolate_in_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extrapolate=false</strong> &#8211; allow current data to be extrapolated
before and after file data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.offset_time">
<code class="descname">offset_time</code><span class="sig-paren">(</span><em>time_offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.offset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.offset_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset_time=0</strong> &#8211; allow data to be in GMT with a time zone offset
(hours).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_offset_time">
<code class="descname">get_offset_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/current_movers.html#GridCurrentMover.get_offset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_offset_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset_time=0</strong> &#8211; allow data to be in GMT with a time zone offset
(hours).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_cell_center_points">
<code class="descname">get_cell_center_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_cell_center_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Right now the cython mover only gets the triangular center points,
so we need to calculate centers based on the cells themselves.</p>
<p>Cells will have the format (tl, tr, bl, br)
We need to get the rectangular centers
Center will be: (tl + ((br - tl) / 2.))</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_cells">
<code class="descname">get_cells</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Invokes the GetCellDataHdl method of TimeGridVel_c object.
Cross-references point data to get cell coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of Cython wrapped C++ movers
Override for things like the WindMover since it has a different
implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; spill_container.SpillContainer object</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_triangle_center_points">
<code class="descname">get_triangle_center_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_triangle_center_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Right now the cython mover only gets the triangular center points.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.get_triangles">
<code class="descname">get_triangles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.get_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Invokes the GetToplogyHdl method of TimeGridVel_c object.
Cross-references point data to get triangle coordinates.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridCurrentMover.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.movers.GridCurrentMover.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridCurrentMover.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.movers.GridCurrentMover.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Default implementation of prepare_for_model_step(...)</dt>
<dd><ul class="first last simple">
<li>Sets the mover&#8217;s active flag if time is within specified timespan
(done in base class Mover)</li>
<li>Invokes the cython mover&#8217;s prepare_for_model_step</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Uses super to invoke Mover class prepare_for_model_step and does a
couple more things specific to CyMover.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> &#8211; tells object whether serialization is for web content
or for generating a save file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridCurrentMover.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridCurrentMover.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.WindMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">WindMover</code><span class="sig-paren">(</span><em>wind=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.movers.wind_movers.WindMoversBase</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>Python wrapper around the Cython wind_mover module.
This class inherits from CyMover and contains CyWindMover</p>
<p>The real work is done by the CyWindMover object.  CyMover
sets everything up that is common to all movers.</p>
<p>Uses super to call CyMover base class __init__</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wind</strong> &#8211; wind object &#8211; provides the wind time series for the mover</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto WindMoversBase __init__ using super.
See Mover documentation for remaining valid kwargs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Can be initialized with wind=None; however, wind must be
set before running. If wind is not None, toggle make_default_refs
to False since user provided a valid Wind and does not wish to
use the default from the Model.</p>
</div>
<dl class="method">
<dt id="gnome.movers.WindMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>if wind attribute is not set, raise ReferencedObjectNotSet excpetion</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.WindMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Since &#8216;wind&#8217; property is saved as a reference when used in save file
and &#8216;save&#8217; option, need to add appropriate node to WindMover schema</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.movers.WindMover.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#WindMover.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.WindMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for wind object</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.movers.GridWindMover">
<em class="property">class </em><code class="descclassname">gnome.movers.</code><code class="descname">GridWindMover</code><span class="sig-paren">(</span><em>wind_file</em>, <em>topology_file=None</em>, <em>extrapolate=False</em>, <em>time_offset=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wind_file</strong> &#8211; file containing wind data on a grid</li>
<li><strong>topology_file</strong> &#8211; Default is None. When exporting topology, it
is stored in this file</li>
<li><strong>wind_scale</strong> &#8211; Value to scale wind data</li>
<li><strong>extrapolate</strong> &#8211; Allow current data to be extrapolated before and
after file data</li>
<li><strong>time_offset</strong> &#8211; Time zone shift if data is in GMT</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Pass optional arguments to base class
uses super: super(GridWindMover,self).__init__(**kwargs)</p>
<dl class="attribute">
<dt id="gnome.movers.GridWindMover.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.movers.GridWindMover.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.export_topology">
<code class="descname">export_topology</code><span class="sig-paren">(</span><em>topology_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover.export_topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover.export_topology" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topology_file=None</strong> &#8211; absolute or relative path where topology
file will be written.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.extrapolate_in_time">
<code class="descname">extrapolate_in_time</code><span class="sig-paren">(</span><em>extrapolate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover.extrapolate_in_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover.extrapolate_in_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extrapolate=false</strong> &#8211; Allow current data to be extrapolated before
and after file data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.offset_time">
<code class="descname">offset_time</code><span class="sig-paren">(</span><em>time_offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/movers/wind_movers.html#GridWindMover.offset_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.movers.GridWindMover.offset_time" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset_time=0</strong> &#8211; Allow data to be in GMT with a time zone offset
(hours).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.get_move">
<code class="descname">get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Override base class functionality because mover has a different
get_move signature</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of the gnome.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of the model as a date time
object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridWindMover.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.movers.GridWindMover.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.movers.GridWindMover.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.movers.GridWindMover.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model after everything else is done
in a time step, and is intended to perform any necessary clean-up
operations. Subclassed movers can override this method.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_data_for_get_move">
<code class="descname">prepare_data_for_get_move</code><span class="sig-paren">(</span><em>sc</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_data_for_get_move" title="Permalink to this definition">¶</a></dt>
<dd><p>organizes the spill object into inputs for calling with Cython
wrapper&#8217;s get_move(...)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>model_time_datetime</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the contained cython mover&#8217;s prepare_for_model_run()</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Call base class method using super
Also updates windage for this timestep</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sc</strong> &#8211; an instance of gnome.spill_container.SpillContainer class</li>
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time_datetime</strong> &#8211; current time of model as a date time object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> &#8211; tells object whether serialization is for web content
or for generating a save file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.movers.GridWindMover.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.movers.GridWindMover.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.weatherers">
<span id="gnome-weatherers-pygnome-adios-weathering-mass-removal-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.weatherers</span></code> &#8211; PyGnome/Adios weathering/mass removal classes<a class="headerlink" href="#module-gnome.weatherers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.weatherers.Weatherer">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Weatherer</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base Weathering agent.  This is almost exactly like the base Mover
in the way that it acts upon the model.  It contains the same API
as the mover as well. Not Serializable since it does is partial
implementation</p>
<p>Base weatherer class; defines the API for all weatherers
Passes optional arguments to base (Process) class via super. See base
class for optional arguments:  <cite>gnome.movers.mover.Process</cite></p>
<p>adds &#8216;mass_components&#8217;, &#8216;mass&#8217; to array_types since all weatherers
need these.</p>
<dl class="method">
<dt id="gnome.weatherers.Weatherer.initialize_data">
<code class="descname">initialize_data</code><span class="sig-paren">(</span><em>sc</em>, <em>num_released</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer.initialize_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer.initialize_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Let weatherers have a way to customize the initialization of
data arrays. Currently, only some weatherers use this to customize
initialization of data arrays. If movers also move towards this
implementation, then move to &#8216;Process&#8217; base class.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Weatherer.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override for weatherers so they can initialize correct &#8216;mass_balance&#8217;
key and set initial value to 0.0</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Weatherer.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/core.html#Weatherer.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Weatherer.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the equivalent of get_move for weathering processes. It modifies
the SpillContainer&#8217;s data arrays; most weatherers update
&#8216;mass_components&#8217; and &#8216;mass&#8217;</p>
<p>Some objects do not implement this since they update arrays like &#8216;area&#8217;
in model_step_is_done()</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Evaporation">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Evaporation</code><span class="sig-paren">(</span><em>water=None</em>, <em>wind=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; gnome.environment.Conditions object which contains
things like water temperature</li>
<li><strong>wind</strong> (<em>Wind API, specifically must have get_value(time) method</em>) &#8211; wind object for obtaining speed at specified time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.Evaporation.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>add evaporated key to mass_balance
for now also add &#8216;density&#8217; key here
Assumes all spills have the same type of oil</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Evaporation.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>weather elements over time_step</p>
<ul class="simple">
<li>sets &#8216;evaporation&#8217; in sc.mass_balance</li>
<li>currently also sets &#8216;density&#8217; in sc.mass_balance but may update
this as we add more weatherers and perhaps density gets set elsewhere</li>
</ul>
<p>Following diff eq models rate of change each pseudocomponent of oil:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dm</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fw</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="o">/</span><span class="n">B</span> <span class="o">*</span> <span class="n">m</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Over a time-step, A, B, C are assumed constant. m(t) is the component
mass at beginning of timestep; m(t + Dt) is mass at end of timestep:</p>
<div class="highlight-python"><div class="highlight"><pre>m(t + Dt) = m(t) * exp(-L * Dt)
L := (1 - fw) * A/B
</pre></div>
</div>
<p>Define properties for each pseudocomponent of oil and constants:</p>
<div class="highlight-python"><div class="highlight"><pre>vp: vapor pressure
mw: molecular weight
</pre></div>
</div>
<p>The following quantities are defined for a given blob of oil. The
thickness of the blob is same for all LEs regardless of how many LEs
are used to model the blob:</p>
<div class="highlight-python"><div class="highlight"><pre>area: area computed from fay spreading
m_i: mass of component &#39;i&#39;
sum_m_mw: sum(m_i/mw_i) over all components
</pre></div>
</div>
<p>effect of wind - mass transport coefficient:</p>
<div class="highlight-python"><div class="highlight"><pre>K: See _mass_transport_coeff()
</pre></div>
</div>
<p>Finally, Evaporation of component &#8216;i&#8217; for blob of oil:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">vp</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">gas_constant</span> <span class="o">*</span> <span class="n">water_temp</span> <span class="o">*</span> <span class="n">sum_m_mw</span>
</pre></div>
</div>
<dl class="docutils">
<dt>L becomes::</dt>
<dd>L = (1 - fw) * area * K * vp/(gas_constant * water_temp * sum_m_mw)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Evaporation.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Since &#8216;wind&#8217;/&#8217;water&#8217; property is saved as references in save file
need to add appropriate node to WindMover schema for &#8216;webapi&#8217;</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.Evaporation.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/evaporation.html#Evaporation.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Evaporation.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for wind object</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Emulsification">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Emulsification</code><span class="sig-paren">(</span><em>waves=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; gnome.environment.Conditions object which contains
things like water temperature</li>
<li><strong>waves</strong> (<em>get_emulsification_wind(model_time)</em>) &#8211; waves object for obtaining emulsification wind speed at specified time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.Emulsification.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>add water_content key to mass_balance
Assumes all spills have the same type of oil</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/update arrays used by emulsification module for this timestep:</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>weather elements over time_step
- sets &#8216;water_content&#8217; in sc.mass_balance</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Since &#8216;wind&#8217;/&#8217;waves&#8217; property is saved as references in save file
need to add appropriate node to WindMover schema for &#8216;webapi&#8217;</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.Emulsification.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/emulsification.html#Emulsification.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Emulsification.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for waves object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Emulsification.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.weatherers.Emulsification.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.initialize_data">
<code class="descname">initialize_data</code><span class="sig-paren">(</span><em>sc</em>, <em>num_released</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.initialize_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Let weatherers have a way to customize the initialization of
data arrays. Currently, only some weatherers use this to customize
initialization of data arrays. If movers also move towards this
implementation, then move to &#8216;Process&#8217; base class.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Emulsification.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.weatherers.Emulsification.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Emulsification.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.weatherers.Emulsification.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Emulsification.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Emulsification.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.NaturalDispersion">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">NaturalDispersion</code><span class="sig-paren">(</span><em>waves=None</em>, <em>water=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; gnome.environment.Conditions object which contains
things like water temperature</li>
<li><strong>waves</strong> &#8211; waves object for obtaining wave_height, etc at given time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>add dispersion and sedimentation keys to mass_balance
Assumes all spills have the same type of oil</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Set/update arrays used by dispersion module for this timestep:</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>weather elements over time_step
- sets &#8216;natural_dispersion&#8217; and &#8216;sedimentation&#8217; in sc.mass_balance</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;water&#8217;/&#8217;waves&#8217; property is saved as references in save file</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.NaturalDispersion.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/natural_dispersion.html#NaturalDispersion.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Append correct schema for water / waves</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.NaturalDispersion.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.initialize_data">
<code class="descname">initialize_data</code><span class="sig-paren">(</span><em>sc</em>, <em>num_released</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.initialize_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Let weatherers have a way to customize the initialization of
data arrays. Currently, only some weatherers use this to customize
initialization of data arrays. If movers also move towards this
implementation, then move to &#8216;Process&#8217; base class.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.NaturalDispersion.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.NaturalDispersion.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.NaturalDispersion.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.NaturalDispersion.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Skimmer">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Skimmer</code><span class="sig-paren">(</span><em>amount</em>, <em>units</em>, <em>efficiency</em>, <em>active_start</em>, <em>active_stop</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.weatherers.cleanup.CleanUpBase</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>initialize Skimmer object - calls base class __init__ using super()
active_start and active_stop time are required
cleanup operations must have a valid datetime - cannot use -inf and inf
active_start/active_stop is used to get the mass removal rate</p>
<dl class="attribute">
<dt id="gnome.weatherers.Skimmer.units">
<code class="descname">units</code><a class="headerlink" href="#gnome.weatherers.Skimmer.units" title="Permalink to this definition">¶</a></dt>
<dd><p>return units for amount skimmed</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Skimmer.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>no need to call base class since no new array_types were added</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Skimmer.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Do sub timestep resolution here so numbers add up correctly
Mark LEs to be skimmed - do them in order right now. Assume all LEs
that are released together will be skimmed together since they would
be closer to each other in position.</p>
<p>Assumes: there is more mass in water than amount of mass to be
skimmed. The LEs marked for Skimming are marked only once -
code checks to see if any LEs are marked for skimming and if
none are found, it marks them.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Skimmer.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Skimmer.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Skimmer.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Assumes there is only ever 1 substance being modeled!
remove mass equally from LEs marked to be skimmed</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.weatherers.Burn">
<em class="property">class </em><code class="descclassname">gnome.weatherers.</code><code class="descname">Burn</code><span class="sig-paren">(</span><em>area</em>, <em>thickness</em>, <em>active_start</em>, <em>area_units='m^2'</em>, <em>thickness_units='m'</em>, <em>efficiency=1.0</em>, <em>wind=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the area of boomed oil to be burned.
Cleanup operations must have a valid datetime for active_start,
cannot use -inf. Cannot set active_stop - burn automatically stops
when oil/water thickness reaches 2mm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>area</strong> (<em>float</em>) &#8211; area of boomed oil/water mixture to burn</li>
<li><strong>thickness</strong> (<em>float</em>) &#8211; thickness of boomed oil/water mixture</li>
<li><strong>active_start</strong> (<em>datetime</em>) &#8211; time when the burn starts</li>
<li><strong>area_units</strong> (<em>str</em>) &#8211; default is &#8216;m^2&#8217;</li>
<li><strong>thickness_units</strong> (<em>str</em>) &#8211; default is &#8216;m&#8217;</li>
<li><strong>efficiency</strong> (<em>float</em>) &#8211; burn efficiency, must be greater than 0 and
less than or equal to 1.0</li>
<li><strong>wind</strong> &#8211; gnome.environment.Wind object. Only used to set
efficiency if efficiency is None. Efficiency is defined as:
1 - 0.07 * wind.get_value(model_time)
where wind.get_value(model_time) is value of wind at model_time</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Kwargs passed onto base class:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of object</li>
<li><strong>on</strong> (<em>bool</em>) &#8211; whether object is on or not for the run</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.weatherers.Burn.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>resets internal _oilwater_thickness variable to initial thickness
specified by user and active_stop to &#8216;inf&#8217; again.
initializes sc.mass_balance[&#8216;burned&#8217;] = 0.0</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><ol class="arabic simple">
<li>set &#8216;active&#8217; flag based on active_start, and model_time</li>
<li>Mark LEs to be burned - do them in order right now. Assume all LEs
that are released together will be burned together since they would
be closer to each other in position.
Assumes: there is more mass in water than amount of mass to be
burned. The LEs marked for Burning are marked only once -
during the very first step that the object becomes active</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.weather_elements">
<code class="descname">weather_elements</code><span class="sig-paren">(</span><em>sc</em>, <em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.weather_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.weather_elements" title="Permalink to this definition">¶</a></dt>
<dd><ol class="arabic simple">
<li>figure out the mass to remove for current timestep based on rate and
efficiency. Find fraction of total mass and remove equally from all
&#8216;mass_components&#8217; of LEs marked for burning.</li>
<li>update &#8216;mass&#8217; array and the amount burned in mass_balance dict</li>
<li>append to _burn_duration for each timestep</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;wind&#8217;/&#8217;waves&#8217; property is saved as references in save file
need to add serialized object for &#8216;webapi&#8217;. Burn could have &#8216;wind&#8217; and
ChemicalDispersion could have &#8216;waves&#8217;.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.weatherers.Burn.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/weatherers/cleanup.html#Burn.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.weatherers.Burn.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for wind object</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.datetime_to_seconds">
<code class="descname">datetime_to_seconds</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.datetime_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the time conversion call here - in case we decide to change it, it
only updates here</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Burn.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.weatherers.Burn.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.initialize_data">
<code class="descname">initialize_data</code><span class="sig-paren">(</span><em>sc</em>, <em>num_released</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.initialize_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Let weatherers have a way to customize the initialization of
data arrays. Currently, only some weatherers use this to customize
initialization of data arrays. If movers also move towards this
implementation, then move to &#8216;Process&#8217; base class.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Burn.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.weatherers.Burn.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc in here in
subclassed movers.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.weatherers.Burn.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.weatherers.Burn.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.weatherers.Burn.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.weatherers.Burn.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.environment">
<span id="gnome-environment-pygnome-environment-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.environment</span></code> &#8211; PyGnome environment classes<a class="headerlink" href="#module-gnome.environment" title="Permalink to this headline">¶</a></h2>
<p>environment module</p>
<dl class="class">
<dt id="gnome.environment.Tide">
<em class="property">class </em><code class="descclassname">gnome.environment.</code><code class="descname">Tide</code><span class="sig-paren">(</span><em>filename</em>, <em>yeardata='/Users/chris.barker/HAZMAT/GNOME2-git/GitLab/pygnome/py_gnome/gnome/data/yeardata'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/tide.html#Tide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Tide" title="Permalink to this definition">¶</a></dt>
<dd><p>todo: baseclass called ScaleTimeseries (or something like that)
ScaleCurrent
Define the tide for a spill</p>
<p>Currently, this internally defines and uses the CyShioTime object, which is
a cython wrapper around the C++ Shio object</p>
<p>Tide information can be obtained from a filename or set as a
timeseries (timeseries is NOT TESTED YET)</p>
<p>It requires one of the following to initialize:</p>
<blockquote>
<div><ol class="arabic simple">
<li>&#8216;timeseries&#8217; assumed to be in &#8216;uv&#8217; format
(NOT TESTED/IMPLEMENTED OR USED YET)</li>
<li>a &#8216;filename&#8217; containing a header that defines units amongst
other meta data</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timeseries</strong> (<em>numpy.ndarray with dtype=datetime_value_1d</em>) &#8211; numpy array containing tide data</li>
<li><strong>units</strong> &#8211; units associated with the timeseries data. If &#8216;filename&#8217;
is given, then units are read in from the filename.
unit_conversion - NOT IMPLEMENTED YET</li>
<li><strong>filename</strong> &#8211; path to a long wind filename from which to read
wind data</li>
<li><strong>yeardata='gnome/data/yeardata/'</strong> &#8211; path to yeardata used for Shio
data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="gnome.environment.Tide.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.environment.Tide.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Tide.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.environment.Tide.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Tide.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.environment.Tide.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform
any actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform
any actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object state as json to user specified saveloc</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>saveloc</strong> (<em>A path as a string or unicode</em>) &#8211; zip archive or a valid directory. Model files are
either persisted here or a new model is re-created from the files
stored here. The files are clobbered when save() is called.</li>
<li><strong>name=None</strong> &#8211; filename to store json. If None, default name is:
&#8220;{0}.json&#8221;.format(self.__class__.__name__). If saveloc is zipfile,
this is the name of archive in which json for self is stored.</li>
<li><strong>references</strong> &#8211; dict of references mapping &#8216;id&#8217; to a string used for
the reference. The value could be a unique integer or it could be
a filename. It is upto the creator of the reference list to decide
how to reference a nested object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> &#8211; tells object whether serialization is for web content
or for generating a save file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>All pygnome objects should be able to validate themselves. Many
py_gnome objects reference other objects like wind, water, waves. These
may not be defined when object is created so they can be None at
construction time; however, they should reference valid objects
when running model. If make_default_refs is True, then object isvalid
because model will set these up at runtime. To raise exception
for missing references at runtime, directly call
validate_refs(level=&#8217;error&#8217;)</p>
<p>&#8216;wind&#8217;, &#8216;water&#8217;, &#8216;waves&#8217; attributes also have special meaning. An
object containing this attribute references the corresponding object.</p>
<p>Logs warnings:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple of length two containing:
(a list of messages that were logged, isvalid bool)
If any references are missing and make_default_refs is False,
object is not valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Tide.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Tide.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.environment.Wind">
<em class="property">class </em><code class="descclassname">gnome.environment.</code><code class="descname">Wind</code><span class="sig-paren">(</span><em>timeseries=None</em>, <em>units=None</em>, <em>filename=None</em>, <em>format='r-theta'</em>, <em>latitude=None</em>, <em>longitude=None</em>, <em>speed_uncertainty_scale=0.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the Wind conditions for a spill</p>
<p>todo: update docstrings!</p>
<dl class="attribute">
<dt id="gnome.environment.Wind.name">
<code class="descname">name</code><a class="headerlink" href="#gnome.environment.Wind.name" title="Permalink to this definition">¶</a></dt>
<dd><p>define as property in base class so all objects will have a name
by default</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.timeseries">
<code class="descname">timeseries</code><a class="headerlink" href="#gnome.environment.Wind.timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>returns entire timeseries in &#8216;r-theta&#8217; format in the units in which
the data was entered or as specified by units attribute</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.timeseries_to_dict">
<code class="descname">timeseries_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.timeseries_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.timeseries_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>when serializing data - round it to 2 decimal places</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.units">
<code class="descname">units</code><a class="headerlink" href="#gnome.environment.Wind.units" title="Permalink to this definition">¶</a></dt>
<dd><p>define units in which wind data is input/output</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Write Wind timeseries to file or to zip,
then call save method using super</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>update attributes from dict - override base class because we want to
set the units before updating the data so conversion is done correctly.
Internally all data is stored in SI units.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.deserialize">
<code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.deserialize_oc">
<code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.get_timeseries">
<code class="descname">get_timeseries</code><span class="sig-paren">(</span><em>datetime=None</em>, <em>format='uv'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.get_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeseries in requested format. If datetime=None,
then the original timeseries that was entered is returned.
If datetime is a list containing datetime objects, then the value
for each of those date times is determined by the underlying
C++ object and the timeseries is returned.</p>
<p>The output format is defined by the strings &#8216;r-theta&#8217;, &#8216;uv&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datetime</strong> (<em>datetime object</em>) &#8211; [optional] datetime object or list of datetime
objects for which the value is desired</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.ts_format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series:
either &#8216;r-theta&#8217; or &#8216;uv&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing dtype=basic_types.datetime_value_2d.
Contains user specified datetime and the corresponding
values in user specified ts_format</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.get_wind_data">
<code class="descname">get_wind_data</code><span class="sig-paren">(</span><em>datetime=None</em>, <em>units=None</em>, <em>format='r-theta'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.get_wind_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.get_wind_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeseries in the requested format. If datetime=None,
then the original timeseries that was entered is returned.
If datetime is a list containing datetime objects, then the value
for each of those date times is determined by the underlying
C++ object and the timeseries is returned.</p>
<p>The output format is defined by the strings &#8216;r-theta&#8217;, &#8216;uv&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datetime</strong> (<em>datetime object</em>) &#8211; [optional] datetime object or list of datetime
objects for which the value is desired</li>
<li><strong>units</strong> (<em>string. Uses the unit_conversion module.</em>) &#8211; [optional] outputs data in these units. Default is to
output data without unit conversion</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.ts_format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series:
either &#8216;r-theta&#8217; or &#8216;uv&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing dtype=basic_types.datetime_value_2d.
Contains user specified datetime and the corresponding
values in user specified ts_format</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Invokes self._convert_units() to do the unit conversion.
Override this method to define the derived object&#8217;s unit conversion
functionality</p>
</div>
<p>todo: return data in appropriate significant digits</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.id">
<code class="descname">id</code><a class="headerlink" href="#gnome.environment.Wind.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method for more exotic forms of identification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a unique ID assigned during construction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.is_sparse">
<code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc=None</em>, <em>references=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<ul class="simple">
<li>load json for references from files</li>
<li>update paths of datafiles if needed</li>
<li>deserialize json_data</li>
<li>and create object with new_from_dict()</li>
</ul>
<dl class="docutils">
<dt>json_data: dict containing json data. It has been parsed through the</dt>
<dd>json.loads() command. The json will be valided here when it gets
deserialized. Its references and datafile paths will be recreated
here prior to calling new_from_dict()</dd>
</dl>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>saveloc</strong> &#8211; location of data files or *.json files for objects
stored as references. If object requires no datafiles and does not
need to read references from a *.json file in saveloc, then this
can be None.</li>
<li><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">object constructed from json_data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gnome.environment.Wind.logger">
<code class="descname">logger</code><a class="headerlink" href="#gnome.environment.Wind.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>define attribute &#8216;_log&#8217;. If it doesn&#8217;t exist, define it here.
This is so we don&#8217;t have to add it to all PyGnome classes - this
property makes the logger available to each object.
- default log_level is INFO</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.new_from_dict">
<code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform
any actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>model_time</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this method if a derived environment class needs to perform
any actions prior to a model run</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> &#8211; tells object whether serialization is for web content
or for generating a save file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_timeseries">
<code class="descname">set_timeseries</code><span class="sig-paren">(</span><em>datetime_value_2d</em>, <em>format='uv'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.set_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the timeseries to the new value given by a numpy array.  The
format for the input data defaults to
basic_types.format.magnitude_direction but can be changed by the user
Assumes timeseries is valid so _check_timeseries has been invoked
and any unit conversions are done. This function simply converts
datetime_value_2d to time_value_pair and updates the data in underlying
cython/C++ object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datetime_value_2d</strong> (<em>numpy array of dtype
basic_types.datetime_value_2d</em>) &#8211; timeseries of wind data defined in a
numpy array</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series; as defined by
basic_types.format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.validate_refs">
<code class="descname">validate_refs</code><span class="sig-paren">(</span><em>refs=['wind', 'water', 'waves']</em><span class="sig-paren">)</span><a class="headerlink" href="#gnome.environment.Wind.validate_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>level is the logging level to use for messages. Default is &#8216;warning&#8217;
but if called from prepare_for_model_run, we want to use error and
raise exception.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_wind_data">
<code class="descname">set_wind_data</code><span class="sig-paren">(</span><em>wind_data</em>, <em>units</em>, <em>format='r-theta'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.set_wind_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.set_wind_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the timeseries of the Wind object to the new value given by
a numpy array.  The format for the input data defaults to
basic_types.format.magnitude_direction but can be changed by the user.
Units are also required with the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datetime_value_2d</strong> (<em>numpy array of dtype
basic_types.datetime_value_2d</em>) &#8211; timeseries of wind data defined in a
numpy array</li>
<li><strong>units</strong> &#8211; units associated with the data. Valid units defined in
Wind.valid_vel_units list</li>
<li><strong>format</strong> (<em>either string or integer value defined by
basic_types.format.* (see cy_basic_types.pyx)</em>) &#8211; output format for the times series; as defined by
basic_types.format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.get_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value at specified time and location. Wind timeseries are
independent of location; however, a gridded datafile may require
location so this interface may get refactored if it needs to support
different types of wind data. It returns the data in SI units (m/s)
in &#8216;r-theta&#8217; format (speed, direction)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> (<em>datetime object or sequence of datetime objects.</em>) &#8211; the time(s) you want the data for</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It invokes get_wind_data(..) function</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.set_speed_uncertainty">
<code class="descname">set_speed_uncertainty</code><span class="sig-paren">(</span><em>up_or_down=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.set_speed_uncertainty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.set_speed_uncertainty" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shifts the wind speed values in our time series
based on a single parameter Rayleigh distribution method,
and scaled by a value in the range [0.0 ... 0.5].
This range represents a plus-or-minus percent of uncertainty that
the distribution function should calculate</p>
<p>For each wind value in our time series:</p>
<ul class="simple">
<li>We assume it to be the average speed for that sample time</li>
<li>We calculate its respective Rayleigh distribution mode (sigma).</li>
<li>We determine either an upper percent uncertainty or a
lower percent uncertainty based on a passed in parameter.</li>
<li>Using the Rayleigh Quantile method and our calculated percent,
we determine the wind speed that is just at or above the
fractional area under the Probability distribution.</li>
<li>We assign the wind speed to its new calculated value.</li>
</ul>
<p>Since we are irreversibly changing the wind speed values,
we should probably do this only once.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.environment.Wind.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/environment/wind.html#Wind.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.environment.Wind.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>only issues warning - object is always valid</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.outputters">
<span id="gnome-outputter-pygnome-outputters-module"></span><h2><code class="docutils literal"><span class="pre">gnome.outputter</span></code> &#8211; PyGnome outputters module<a class="headerlink" href="#module-gnome.outputters" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.outputters.Outputter">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">Outputter</code><span class="sig-paren">(</span><em>cache=None</em>, <em>on=True</em>, <em>output_timestep=None</em>, <em>output_zero_step=True</em>, <em>output_last_step=True</em>, <em>name=''</em>, <em>output_dir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>base class for all outputters
Since this outputter doesn&#8217;t do anything, it&#8217;ll never be used as part
of a gnome model. As such, it should never need to be serialized</p>
<p>sets attributes for all outputters, like output_timestep, cache</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache</strong> &#8211; sets the cache object from which to read data. The model
will automatically set this param</li>
<li><strong>output_timestep</strong> (<em>timedelta object</em>) &#8211; default is None in which case every time the
write_output is called, output is written. If set, then output is
written every output_timestep starting from model_start_time.</li>
<li><strong>output_zero_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
initial step (showing initial release conditions) is written
regardless of output_timestep</li>
<li><strong>output_last_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
final step is written regardless of output_timestep</li>
<li><strong>name=''</strong> &#8211; name for outputter</li>
<li><strong>output_dir=None</strong> &#8211; directory to dump ouput in, if it needs to
do this.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.outputters.Outputter.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_start_time=None</em>, <em>spills=None</em>, <em>model_time_step=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model at the beginning of a new run.
Do what you need to do to prepare.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model_start_time</strong> (<em>datetime.datetime object</em>) &#8211; (Required) start time of the model run.
NetCDF time units calculated with respect
to this time.</li>
<li><strong>spills</strong> (<em>gnome.spill_container.SpillContainerPair object</em>) &#8211; (Required) model.spills object (SpillContainerPair)</li>
<li><strong>model_time_step</strong> (<em>float seconds</em>) &#8211; time step of the model
&#8211; used to set timespans for some outputters</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional argument - in case cache needs to be updated</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cache=None</strong> &#8211; Sets the cache object to be used for the data.
If None, it will use the one already set up.</td>
</tr>
</tbody>
</table>
<p>also added <code class="docutils literal"><span class="pre">**kwargs</span></code> since a derived class like NetCDFOutput could
require additional variables.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">base class doesn&#8217;t use model_start_time or spills, but
multiple outputters need spills and netcdf needs model_start_time,
so just set them here</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Outputter.prepare_for_model_step">
<code class="descname">prepare_for_model_step</code><span class="sig-paren">(</span><em>time_step</em>, <em>model_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.prepare_for_model_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.prepare_for_model_step" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model at the beginning of each time step
Do what you need to do to prepare for a new model step</p>
<p>base class method checks to see if data for model_time should be output
Set self._write_step flag to true if:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt_since_lastoutput</span> <span class="o">&lt;=</span> <span class="n">model_time</span> <span class="o">+</span> <span class="n">time_step</span>
</pre></div>
</div>
<p>It also updates the _dt_since_lastoutput internal variable if the data
from this step will be written to output</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_step</strong> &#8211; time step in seconds</li>
<li><strong>model_time</strong> &#8211; current model time as datetime object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The write_output() method will be called after the Model
calls model_step_is_done(). Let&#8217;s set the _write_step flag here and
update the _dt_since_lastoutput variable</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Outputter.model_step_is_done">
<code class="descname">model_step_is_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.model_step_is_done"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.model_step_is_done" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gets called by the model when after everything else is done
in a time step. Put any code need for clean-up, etc.
The write_output method is called by Model after all processing.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Outputter.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>called by the model at the end of each time step
This is the last operation after model_step_is_done()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_num</strong> (<em>int</em>) &#8211; the model step number you want rendered.</li>
<li><strong>islast_step</strong> (<em>bool</em>) &#8211; default is False. Flag that indicates that step_num
is last step. If &#8216;output_last_step&#8217; is True then this is written
out</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Outputter.clean_output_files">
<code class="descname">clean_output_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.clean_output_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.clean_output_files" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans out the output dir</p>
<p>This should be implemented by subclasses that dump files.</p>
<p>but each outputter type dumps different types of files, and this should
only clear out those. So it has to be custom implemented</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Outputter.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by model.rewind()</p>
<p>Reset variables set during prepare_for_model_run() to init conditions
Make sure all child classes call parent rewind() first!</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Outputter.write_output_post_run">
<code class="descname">write_output_post_run</code><span class="sig-paren">(</span><em>model_start_time</em>, <em>num_time_steps</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/outputter.html#Outputter.write_output_post_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Outputter.write_output_post_run" title="Permalink to this definition">¶</a></dt>
<dd><p>If the model has already been run and the data is cached, then use
this function to write output. In this case, num_time_steps is known
so pass it into this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>model_start_time</strong> (<em>datetime.datetime object</em>) &#8211; (Required) start time of the model run. NetCDF
time units calculated with respect to this time.</li>
<li><strong>num_time_steps</strong> (<em>int</em>) &#8211; (Required) total number of time steps for the
run. Currently this is known and fixed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional argument - depending on the outputter, the following maybe
required. For instance, the &#8216;spills&#8217; are required by NetCDFOutput,
GeoJson, but not Renderer in prepare_for_model_run(). The <code class="docutils literal"><span class="pre">**kwargs</span></code>
here are those required by prepare_for_model_run() for an outputter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache=None</strong> &#8211; Sets the cache object to be used for the data.
If None, it will use the one already set up.</li>
<li><strong>uncertain</strong> (<em>bool</em>) &#8211; is there uncertain data to write. Used by
NetCDFOutput to setup attributes for uncertain data file</li>
<li><strong>spills</strong> (<em>This is the Model&#8217;s spills attribute which refers to the
SpillContainerPair object</em>) &#8211; SpillContainerPair object containing spill information
Used by both the NetCDFOutput and by GeoJson to obtain spill_id
from spill_num</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Follows the iteration in Model().step() for each step_num</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.outputters.Renderer">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">Renderer</code><span class="sig-paren">(</span><em>map_filename=None, output_dir='./', image_size=(800, 600), projection=None, viewport=None, map_BB=None, land_polygons=None, draw_back_to_fore=True, draw_map_bounds=False, draw_spillable_area=False, cache=None, output_timestep=None, output_zero_step=True, output_last_step=True, draw_ontop='forecast', name=None, on=True, formats=['png', 'gif'], timestamp_attrib={}, **kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.outputters.outputter.Outputter</span></code>, <a class="reference internal" href="#gnome.utilities.map_canvas.MapCanvas" title="gnome.utilities.map_canvas.MapCanvas"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.map_canvas.MapCanvas</span></code></a></p>
<p>Map Renderer</p>
<dl class="docutils">
<dt>class that writes map images for GNOME results:</dt>
<dd>writes the frames for the LE &#8220;movies&#8221;, etc.</dd>
</dl>
<p>Init the image renderer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map_filename=None</strong> &#8211; name of file for basemap (BNA)</li>
<li><strong>output_dir='./'</strong> &#8211; directory to output the images</li>
<li><strong>600)</strong> (<em>image_size=(800,</em>) &#8211; size of images to output</li>
<li><strong>projection=None</strong> &#8211; projection instance to use:
if None, set to
projections.FlatEarthProjection()</li>
<li><strong>viewport</strong> (<em>pair of (lon, lat) tuples ( lower_left, upper right )</em>) &#8211; viewport of map &#8211; what gets drawn and on what scale.
Default is full globe: (((-180, -90), (180, 90)))</li>
<li><strong>map_BB=None</strong> &#8211; bounding box of map if None, it will use the
bounding box of the mapfile.</li>
<li><strong>draw_back_to_fore=True</strong> &#8211; draw the background (map) to the
foregound image when outputting
the images each time step.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Following args are passed to base class Outputter&#8217;s init:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache</strong> &#8211; sets the cache object from which to read data. The model
will automatically set this param</li>
<li><strong>output_timestep</strong> (<em>timedelta object</em>) &#8211; default is None in which case everytime the
write_output is called, output is written. If set, then output is
written every output_timestep starting from model_start_time.</li>
<li><strong>output_zero_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
initial step (showing initial release conditions) is written
regardless of output_timestep</li>
<li><strong>output_last_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
final step is written regardless of output_timestep</li>
<li><strong>draw_ontop</strong> (<em>str</em>) &#8211; draw &#8216;forecast&#8217; or &#8216;uncertain&#8217; LEs on top. Default
is to draw &#8216;forecast&#8217; LEs, which are in black on top</li>
<li><strong>formats</strong> (<em>list of strings</em>) &#8211; list of formats to output.
Default is .png and animated .gif</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Remaining kwargs are passed onto baseclass&#8217;s __init__ with a direct
call: Outputter.__init__(..)</p>
<dl class="classmethod">
<dt id="gnome.outputters.Renderer.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>change projection_type from string to correct type for loading from
save file</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares the renderer for a model run.</p>
<p>Parameters passed to base class (use super): model_start_time, cache</p>
<p>Does not take any other input arguments; however, to keep the interface
the same for all outputters, define <code class="docutils literal"><span class="pre">**kwargs</span></code> and pass into the
base class</p>
<p>In this case, it draws the background image and clears the previous
images. If you want to save the previous images, a new output dir
should be set.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.set_timestamp_attrib">
<code class="descname">set_timestamp_attrib</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.set_timestamp_attrib"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.set_timestamp_attrib" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to set details of the timestamp&#8217;s appearance when printed.
These details are stored as a dict.</p>
<p>Recognized attributes:
:param on: Turn the draw function on or off
:type on: Boolean</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dt_format</strong> (<em>String</em>) &#8211; Format string for strftime to format the timestamp</li>
<li><strong>background</strong> (<em>String</em>) &#8211; Color of the text background.
Color must be present in foreground palette</li>
<li><strong>color</strong> (<em>String</em>) &#8211; Color of the font. Note that the color must be present
in the foreground palette</li>
<li><strong>size</strong> (<em>One of: (&#8216;tiny&#8217;, &#8216;small&#8217;, &#8216;medium&#8217;, &#8216;large&#8217;, &#8216;giant&#8217;)</em>) &#8211; Size of the font</li>
<li><strong>position</strong> &#8211; x, y pixel coordinates of where to draw the timestamp.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:type position :tuple</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>align</strong> (<em>One of: (&#8216;lt&#8217;(left top), &#8216;ct&#8217;, &#8216;rt&#8217;,
&#8216;l&#8217;, &#8216;r&#8217;,
&#8216;rb&#8217;, &#8216;cb&#8217;, &#8216;lb&#8217;)</em>) &#8211; The reference point of the text bounding box.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.draw_timestamp">
<code class="descname">draw_timestamp</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.draw_timestamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.draw_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that draws the timestamp to the foreground.
Uses self.timestamp_attribs to determine it&#8217;s appearance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> (<em>datetime</em>) &#8211; the datetime object representing the timestamp</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.draw_background">
<code class="descname">draw_background</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.draw_background"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.draw_background" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the background image &#8211; just land for now</p>
<p>This should be called whenever the scale changes</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.draw_land">
<code class="descname">draw_land</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.draw_land"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.draw_land" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the land map to the internal background image.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.draw_elements">
<code class="descname">draw_elements</code><span class="sig-paren">(</span><em>sc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.draw_elements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.draw_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the individual elements to a foreground image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sc</strong> &#8211; a SpillContainer object to draw</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.draw_raster_map">
<code class="descname">draw_raster_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.draw_raster_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.draw_raster_map" title="Permalink to this definition">¶</a></dt>
<dd><p>draws the raster map used for beaching to the image.</p>
<p>draws a grid for the pixels</p>
<p>this is pretty slow, but only used for diagnostics.
(not bad for just the lines)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the map image, according to current parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>step_num</strong> (<em>int</em>) &#8211; the model step number you want rendered.</li>
<li><strong>islast_step</strong> (<em>bool</em>) &#8211; default is False. Flag that indicates that step_num
is last step. If &#8216;output_last_step&#8217; is True then this is written
out</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dict of info about this step number if this step
is to be output, None otherwise.
&#8216;step_num&#8217;: step_num
&#8216;image_filename&#8217;: filename
&#8216;time_stamp&#8217;: time_stamp # as ISO string</p>
</td>
</tr>
</tbody>
</table>
<p>use super to call base class write_output method</p>
<p>If this is last step, then data is written; otherwise
prepare_for_model_step determines whether to write the output for
this step based on output_timestep</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.projection_to_dict">
<code class="descname">projection_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.projection_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.projection_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>store projection class as a string for now since that is all that
is required for persisting
todo: This may not be the case for all projection classes, but keep
simple for now so we don&#8217;t have to make the projection classes
serializable</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.Renderer.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>update the &#8216;output_dir&#8217; key in the <a href="#id3"><span class="problematic" id="id4">json_</span></a> to point to directory
inside saveloc, then save the json - do not copy image files or
image directory over</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.outputters.Renderer.loads">
<em class="property">classmethod </em><code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc</em>, <em>references=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/renderer.html#Renderer.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.Renderer.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<p>prepend saveloc path to &#8216;output_dir&#8217; and create output_dir in saveloc,
then call super to load object</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.outputters.NetCDFOutput">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">NetCDFOutput</code><span class="sig-paren">(</span><em>netcdf_filename</em>, <em>which_data='standard'</em>, <em>compress=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.outputters.outputter.Outputter</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>A NetCDFOutput object is used to write the model&#8217;s data to a NetCDF file.
It inherits from Outputter class and implements the same interface.</p>
<p>This class is meant to be used within the Model, to be added to list of
outputters.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">gnome</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">outputters</span> <span class="o">+=</span> <span class="n">gnome</span><span class="o">.</span><span class="n">netcdf_outputter</span><span class="o">.</span><span class="n">NetCDFOutput</span><span class="p">(</span>
<span class="go">            os.path.join(base_dir,&#39;sample_model.nc&#39;), which_data=&#39;most&#39;)</span>
</pre></div>
</div>
<p><cite>which_data</cite> flag is used to set which data to add to the netcdf file:</p>
<p>&#8216;standard&#8217; : the basic stuff most people would want</p>
<p>&#8216;most&#8217;: everything the model is tracking except the internal-use-only arrays</p>
<p>&#8216;all&#8217;: everything tracked by the model (mostly used for diagnostics of save files)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>cf_attributes is a class attribute: a dict
that contains the global attributes per CF convention</p>
<p>The attribute: <cite>.arrays_to_output</cite> is a set of the data arrays that
will be added to the netcdf file. array names may be added to or removed
from this set before a model run to customize what gets output:
<cite>the_netcdf_outputter.arrays_to_output.add[&#8216;rise_vel&#8217;]</cite></p>
<p class="last">Since some of the names of the netcdf variables are different from the
names in the SpillContainer data_arrays, this list uses the netcdf names</p>
</div>
<p>Constructor for Net_CDFOutput object. It reads data from cache and
writes it to a NetCDF4 format file using the CF convention</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>netcdf_filename</strong> (<em>str. or unicode</em>) &#8211; Required parameter. The filename in which to
store the NetCDF data.</li>
<li><strong>which_data='standard'</strong> &#8211; If &#8216;standard&#8217;, write only standard data.
If &#8216;most&#8217; means, write everything except the attributes we know are
for internal model use.
If &#8216;all&#8217;, write all data to NetCDF &#8211; usually only for diagnostics.
Default is &#8216;standard&#8217;.
These are defined in the standard_arrays and usually_skipped_arrays
attributes</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional arguments passed on to base class (kwargs):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache</strong> &#8211; sets the cache object from which to read data. The model
will automatically set this param</li>
<li><strong>output_timestep</strong> (<em>timedelta object</em>) &#8211; default is None in which case every time the
write_output is called, output is written. If set, then output is
written every output_timestep starting from model_start_time.</li>
<li><strong>output_zero_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
initial step (showing initial release conditions) is written
regardless of output_timestep</li>
<li><strong>output_last_step</strong> (<em>boolean</em>) &#8211; default is True. If True then output for
final step is written regardless of output_timestep</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>use super to pass optional kwargs to base class __init__ method</p>
<dl class="attribute">
<dt id="gnome.outputters.NetCDFOutput.uncertain_filename">
<code class="descname">uncertain_filename</code><a class="headerlink" href="#gnome.outputters.NetCDFOutput.uncertain_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>if uncertain SpillContainer is present, write its data out to this file</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.NetCDFOutput.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_start_time</em>, <em>spills</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="function">
<dt>
<code class="descname">prepare_for_model_run(model_start_time,</code></dt>
<dt>
<code class="descname">cache=None,</code></dt>
<dt>
<code class="descname">uncertain=False,</code></dt>
<dt>
<code class="descname">spills=None,</code></dt>
<dt>
<code class="descname">**kwargs)</code></dt>
<dd></dd></dl>

<p>Write global attributes and define dimensions and variables for NetCDF
file.
This must be done in prepare_for_model_run because if model _state
changes, it is rewound and re-run from the beginning.</p>
<p>If there are existing output files, they are deleted here.</p>
<p>This takes more than standard &#8216;cache&#8217; argument. Some of these are
required arguments - they contain None for defaults because non-default
argument cannot follow default argument. Since cache is already 2nd
positional argument for Renderer object, the required non-default
arguments must be defined following &#8216;cache&#8217;.</p>
<p>If uncertainty is on, then SpillContainerPair object contains
identical _data_arrays in both certain and uncertain SpillContainer&#8217;s,
the data itself is different, but they contain the same type of data
arrays. If uncertain, then datay arrays for uncertain spill container
are written to netcdf_filename + &#8216;_uncertain.nc&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spills</strong> (<em>gnome.spill_container.SpillContainerPair object.</em>) &#8211; If &#8216;which_data&#8217; flag is set to &#8216;all&#8217; or &#8216;most&#8217;, then
model must provide the model.spills object
(SpillContainerPair object) so NetCDF variables can be
defined for the remaining data arrays.
If spills is None, but which_data flag is &#8216;all&#8217; or
&#8216;most&#8217;, a ValueError will be raised.
It does not make sense to write &#8216;all&#8217; or &#8216;most&#8217; but not
provide &#8216;model.spills&#8217;.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Does not take any other input arguments; however, to keep the
interface the same for all outputters, define <code class="docutils literal"><span class="pre">**kwargs</span></code> in case
future outputters require different arguments.</p>
</div>
<p>use super to pass model_start_time, cache=None and
remaining kwargs to base class method</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.NetCDFOutput.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write NetCDF output at the end of the step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_num</strong> (<em>int</em>) &#8211; the model step number you want rendered.</li>
<li><strong>islast_step</strong> (<em>bool</em>) &#8211; Default is False.
Flag that indicates that step_num is
last step.
If &#8216;output_last_step&#8217; is True then this is
written out</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Use super to call base class write_output method</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.NetCDFOutput.clean_output_files">
<code class="descname">clean_output_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.clean_output_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.clean_output_files" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes output files that may be around</p>
<p>called by prepare_for_model_run</p>
<p>here in case it needs to be called from elsewhere</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.NetCDFOutput.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a few parameter and call base class rewind to reset
internal variables.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.outputters.NetCDFOutput.read_data">
<em class="property">classmethod </em><code class="descname">read_data</code><span class="sig-paren">(</span><em>klass</em>, <em>netcdf_file</em>, <em>time=None</em>, <em>index=None</em>, <em>which_data='standard'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.read_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.read_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and create standard data arrays for a netcdf file that was created
with NetCDFOutput class. Make it a class method since it is
independent of an instance of the Outputter. The method is put with
this class because the NetCDF functionality for PyGnome data with CF
standard is captured here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>netcdf_file</strong> (<em>str</em>) &#8211; Name of the NetCDF file from which to read
the data</li>
<li><strong>time</strong> (<em>datetime</em>) &#8211; timestamp at which the data is desired. Looks in
the netcdf data&#8217;s &#8216;time&#8217; array and finds the closest time to this
and outputs this data. If both &#8216;time&#8217; and &#8216;index&#8217; are None, return
data if file only contains one &#8216;time&#8217; else raise an error</li>
<li><strong>index</strong> (<em>int</em>) &#8211; Index of the &#8216;time&#8217; variable (or time_step). This is
only used if &#8216;time&#8217; is None. If both &#8216;time&#8217; and &#8216;index&#8217; are None,
return data if file only contains one &#8216;time&#8217; else raise an error</li>
<li><strong>which_data='standard'</strong> &#8211; Which data arrays are desired options are
(&#8216;standard&#8217;, &#8216;most&#8217;, &#8216;all&#8217;, [list_of_array_names])</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dict containing standard data closest to the indicated
&#8216;time&#8217;. Standard data is defined as follows:</p>
</td>
</tr>
</tbody>
</table>
<p>Standard data arrays are numpy arrays of size N, where N is number of
particles released at time step of interest. They are defined by the
class attribute &#8220;standard_arrays&#8221;, currently:</p>
<blockquote>
<div>&#8216;current_time_stamp&#8217;: datetime object associated with this data
&#8216;positions&#8217;         : NX3 array. NetCDF variables: &#8216;longitude&#8217;, &#8216;latitude&#8217;, &#8216;depth&#8217;
&#8216;status_codes&#8217;      : NX1 array. NetCDF variable :&#8217;status_codes&#8217;
&#8216;spill_num&#8217;         : NX1 array. NetCDF variable: &#8216;spill_num&#8217;
&#8216;id&#8217;                : NX1 array of particle id. NetCDF variable &#8216;id&#8217;
&#8216;mass&#8217;              : NX1 array showing &#8216;mass&#8217; of each particle</div></blockquote>
<dl class="docutils">
<dt>standard_arrays = [&#8216;latitude&#8217;,</dt>
<dd>&#8216;longitude&#8217;, # pulled from the &#8216;positions&#8217; array
&#8216;depth&#8217;,
&#8216;status_codes&#8217;,
&#8216;spill_num&#8217;,
&#8216;id&#8217;,
&#8216;mass&#8217;,
&#8216;age&#8217;,
]</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.NetCDFOutput.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>saveloc</em>, <em>references=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.save" title="Permalink to this definition">¶</a></dt>
<dd><p>See baseclass <code class="xref py py-meth docutils literal"><span class="pre">save()</span></code></p>
<p>update netcdf_filename to point to saveloc, then call base class save
using super</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.outputters.NetCDFOutput.loads">
<em class="property">classmethod </em><code class="descname">loads</code><span class="sig-paren">(</span><em>json_data</em>, <em>saveloc</em>, <em>references=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/netcdf.html#NetCDFOutput.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.NetCDFOutput.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>loads object from json_data</p>
<p>update path to &#8216;netcdf_filename&#8217; in json_data, then finish loading
by calling super class&#8217; load method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>saveloc</strong> &#8211; location of data files. Setup path of netcdf_filename
to this location</td>
</tr>
</tbody>
</table>
<p>Optional parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>references</strong> &#8211; references object - if this is called by the Model,
it will pass a references object. It is not required.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.outputters.KMZOutput">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">KMZOutput</code><span class="sig-paren">(</span><em>filename</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/kmz.html#KMZOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.KMZOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.outputters.outputter.Outputter</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>class that outputs GNOME results in a kmz format.</p>
<p>Suitable for Google Earth, and semi-suitable for MarPlot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>output_dir=None</strong> (<em>str</em>) &#8211; output directory for kmz files.</td>
</tr>
</tbody>
</table>
<p>uses super to pass optional **kwargs to base class __init__ method</p>
<dl class="method">
<dt id="gnome.outputters.KMZOutput.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>model_start_time</em>, <em>spills</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/kmz.html#KMZOutput.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.KMZOutput.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="function">
<dt>
<code class="descname">prepare_for_model_run(model_start_time,</code></dt>
<dt>
<code class="descname">cache=None,</code></dt>
<dt>
<code class="descname">uncertain=False,</code></dt>
<dt>
<code class="descname">spills=None,</code></dt>
<dt>
<code class="descname">**kwargs)</code></dt>
<dd></dd></dl>

<p>Write the headers, png files, etc for the KMZ file</p>
<p>This must be done in prepare_for_model_run because if model _state
changes, it is rewound and re-run from the beginning.</p>
<p>If there are existing output files, they are deleted here.</p>
<p>This takes more than standard &#8216;cache&#8217; argument. Some of these are
required arguments - they contain None for defaults because non-default
argument cannot follow default argument. Since cache is already 2nd
positional argument for Renderer object, the required non-default
arguments must be defined following &#8216;cache&#8217;.</p>
<p>If uncertainty is on, then SpillContainerPair object contains
identical _data_arrays in both certain and uncertain SpillContainer&#8217;s,
the data itself is different, but they contain the same type of data
arrays. If uncertain, then data arrays for uncertain spill container
are written to the KMZ file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Does not take any other input arguments; however, to keep the
interface the same for all outputters, define kwargs in case
future outputters require different arguments.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.KMZOutput.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/kmz.html#KMZOutput.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.KMZOutput.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>dump a timestep&#8217;s data into the kmz file</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.KMZOutput.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/kmz.html#KMZOutput.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.KMZOutput.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a few parameter and call base class rewind to reset
internal variables.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.KMZOutput.delete_output_files">
<code class="descname">delete_output_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/kmz.html#KMZOutput.delete_output_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.KMZOutput.delete_output_files" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes ouput files that may be around</p>
<p>called by prepare_for_model_run</p>
<p>here in case it needs to be called from elsewhere</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.outputters.TrajectoryGeoJsonOutput">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">TrajectoryGeoJsonOutput</code><span class="sig-paren">(</span><em>round_data=True</em>, <em>round_to=4</em>, <em>output_dir=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#TrajectoryGeoJsonOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.TrajectoryGeoJsonOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.outputters.outputter.Outputter</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>class that outputs GNOME results in a geojson format. The output is a
collection of Features. Each Feature contains a Point object with
associated properties. Following is the format for a particle - the
data in &lt;&gt; are the results for each element.</p>
<div class="highlight-python"><div class="highlight"><pre>{
&quot;type&quot;: &quot;FeatureCollection&quot;,
&quot;features&quot;: [
    {
        &quot;geometry&quot;: {
            &quot;type&quot;: &quot;Point&quot;,
            &quot;coordinates&quot;: [
                &lt;LONGITUDE&gt;,
                &lt;LATITUDE&gt;
            ]
        },
        &quot;type&quot;: &quot;Feature&quot;,
        &quot;id&quot;: &lt;PARTICLE_ID&gt;,
        &quot;properties&quot;: {
            &quot;current_time&quot;: &lt;TIME IN SEC SINCE EPOCH&gt;,
            &quot;status_code&quot;: &lt;&gt;,
            &quot;spill_id&quot;: &lt;UUID OF SPILL OBJECT THAT RELEASED PARTICLE&gt;,
            &quot;depth&quot;: &lt;DEPTH&gt;,
            &quot;spill_type&quot;: &lt;FORECAST OR UNCERTAIN&gt;,
            &quot;step_num&quot;: &lt;OUTPUT ASSOCIATED WITH THIS STEP NUMBER&gt;
        }
    },
    ...
}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>round_data=True</strong> (<em>bool</em>) &#8211; if True, then round the numpy arrays
containing float to number of digits specified by &#8216;round_to&#8217;.
Default is True</li>
<li><strong>round_to=4</strong> (<em>int</em>) &#8211; round float arrays to these number of digits.
Default is 4.</li>
<li><strong>output_dir=None</strong> (<em>str</em>) &#8211; output directory for geojson files. Default
is None since data is returned in dict for webapi. For using
write_output_post_run(), this must be set</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>use super to pass optional **kwargs to base class __init__ method</p>
<dl class="method">
<dt id="gnome.outputters.TrajectoryGeoJsonOutput.prepare_for_model_run">
<code class="descname">prepare_for_model_run</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#TrajectoryGeoJsonOutput.prepare_for_model_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.TrajectoryGeoJsonOutput.prepare_for_model_run" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares the outputter for a model run.</p>
<p>Parameters passed to base class (use super): model_start_time, cache</p>
<p>Does not take any other input arguments; however, to keep the interface
the same for all outputters, define <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs and pass into base class</p>
<p>In this case, it cleans out previous written data files</p>
<p>If you want to keep them, a new output_dir should be set</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.TrajectoryGeoJsonOutput.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#TrajectoryGeoJsonOutput.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.TrajectoryGeoJsonOutput.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>dump data in geojson format</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.outputters.CurrentGeoJsonOutput">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">CurrentGeoJsonOutput</code><span class="sig-paren">(</span><em>current_movers</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#CurrentGeoJsonOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.CurrentGeoJsonOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.outputters.outputter.Outputter</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>Class that outputs GNOME current velocity results for each current mover
in a geojson format.  The output is a collection of Features.
Each Feature contains a Point object with associated properties.
Following is the output format - the data in &lt;&gt; are the results
for each element.</p>
<div class="highlight-python"><div class="highlight"><pre>{
 &quot;time_stamp&quot;: &lt;TIME IN ISO FORMAT&gt;,
 &quot;step_num&quot;: &lt;OUTPUT ASSOCIATED WITH THIS STEP NUMBER&gt;,
 &quot;feature_collections&quot;: {&lt;mover_id&gt;: {&quot;type&quot;: &quot;FeatureCollection&quot;,
                                      &quot;features&quot;: [{&quot;type&quot;: &quot;Feature&quot;,
                                                    &quot;id&quot;: &lt;PARTICLE_ID&gt;,
                                                    &quot;properties&quot;: {&quot;velocity&quot;: [u, v]
                                                                   },
                                                    &quot;geometry&quot;: {&quot;type&quot;: &quot;Point&quot;,
                                                                 &quot;coordinates&quot;: [&lt;LONG&gt;, &lt;LAT&gt;]
                                                                 },
                                                },
                                                ...
                                               ],
                                  },
                     ...
                     }
}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>current_movers</strong> (<em>list</em>) &#8211; A list or collection of current grid mover
objects.</td>
</tr>
</tbody>
</table>
<p>use super to pass optional **kwargs to base class __init__ method</p>
<dl class="method">
<dt id="gnome.outputters.CurrentGeoJsonOutput.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#CurrentGeoJsonOutput.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.CurrentGeoJsonOutput.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>dump data in geojson format</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.CurrentGeoJsonOutput.get_unique_velocities">
<code class="descname">get_unique_velocities</code><span class="sig-paren">(</span><em>velocities</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#CurrentGeoJsonOutput.get_unique_velocities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.CurrentGeoJsonOutput.get_unique_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>In order to make numpy perform this function fast, we will use a
contiguous structured array using a view of a void type that
joins the whole row into a single item.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.CurrentGeoJsonOutput.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#CurrentGeoJsonOutput.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.CurrentGeoJsonOutput.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>remove previously written files</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.CurrentGeoJsonOutput.current_movers_to_dict">
<code class="descname">current_movers_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#CurrentGeoJsonOutput.current_movers_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.CurrentGeoJsonOutput.current_movers_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>a dict containing &#8216;obj_type&#8217; and &#8216;id&#8217; for each object in
list/collection</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.outputters.IceGeoJsonOutput">
<em class="property">class </em><code class="descclassname">gnome.outputters.</code><code class="descname">IceGeoJsonOutput</code><span class="sig-paren">(</span><em>ice_movers</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.outputters.outputter.Outputter</span></code>, <a class="reference internal" href="#gnome.utilities.serializable.Serializable" title="gnome.utilities.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.serializable.Serializable</span></code></a></p>
<p>Class that outputs GNOME ice velocity results for each ice mover
in a geojson format.  The output is a collection of Features.
Each Feature contains a Point object with associated properties.
Following is the output format - the data in &lt;&gt; are the results
for each element.</p>
<div class="highlight-python"><div class="highlight"><pre>{
 &quot;time_stamp&quot;: &lt;TIME IN ISO FORMAT&gt;,
 &quot;step_num&quot;: &lt;OUTPUT ASSOCIATED WITH THIS STEP NUMBER&gt;,
 &quot;feature_collections&quot;: {&lt;mover_id&gt;: {&quot;type&quot;: &quot;FeatureCollection&quot;,
                                      &quot;features&quot;: [{&quot;type&quot;: &quot;Feature&quot;,
                                                    &quot;id&quot;: &lt;PARTICLE_ID&gt;,
                                                    &quot;properties&quot;: {&quot;ice_fraction&quot;: &lt;FRACTION&gt;,
                                                                   &quot;ice_thickness&quot;: &lt;METERS&gt;,
                                                                   &quot;water_velocity&quot;: [u, v],
                                                                   &quot;ice_velocity&quot;: [u, v]
                                                                   },
                                                    &quot;geometry&quot;: {&quot;type&quot;: &quot;Point&quot;,
                                                                 &quot;coordinates&quot;: [&lt;LONG&gt;, &lt;LAT&gt;]
                                                                 },
                                                    },
                                                    ...
                                                   ],
                                      },
                         ...
                         }
}
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>current_movers</strong> (<em>list</em>) &#8211; A list or collection of current grid mover
objects.</td>
</tr>
</tbody>
</table>
<p>use super to pass optional **kwargs to base class __init__ method</p>
<dl class="method">
<dt id="gnome.outputters.IceGeoJsonOutput.write_output">
<code class="descname">write_output</code><span class="sig-paren">(</span><em>step_num</em>, <em>islast_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput.write_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput.write_output" title="Permalink to this definition">¶</a></dt>
<dd><p>dump data in geojson format</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.IceGeoJsonOutput.get_unique_ice_values">
<code class="descname">get_unique_ice_values</code><span class="sig-paren">(</span><em>ice_values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput.get_unique_ice_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput.get_unique_ice_values" title="Permalink to this definition">¶</a></dt>
<dd><p>In order to make numpy perform this function fast, we will use a
contiguous structured array using a view of a void type that
joins the whole row into a single item.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.IceGeoJsonOutput.get_triangles">
<code class="descname">get_triangles</code><span class="sig-paren">(</span><em>mover</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput.get_triangles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput.get_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>The triangle data that we get from the mover is in the form of
indices into the points array.
So we get our triangle data and points array, and then build our
triangle coordinates by reference.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.IceGeoJsonOutput.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>remove previously written files</p>
</dd></dl>

<dl class="method">
<dt id="gnome.outputters.IceGeoJsonOutput.ice_movers_to_dict">
<code class="descname">ice_movers_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput.ice_movers_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput.ice_movers_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>a dict containing &#8216;obj_type&#8217; and &#8216;id&#8217; for each object in
list/collection</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.outputters.IceGeoJsonOutput.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/outputters/geo_json.html#IceGeoJsonOutput.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.outputters.IceGeoJsonOutput.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>append correct schema for current mover</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.utilities.distributions">
<span id="gnome-utilities-pygnome-utilities-module"></span><h2><code class="docutils literal"><span class="pre">gnome.utilities</span></code> &#8211; PyGnome utilities module<a class="headerlink" href="#module-gnome.utilities.distributions" title="Permalink to this headline">¶</a></h2>
<p>Classes that generate various types of probability distributions</p>
<dl class="class">
<dt id="gnome.utilities.distributions.LogNormalDistributionSchema">
<em class="property">class </em><code class="descclassname">gnome.utilities.distributions.</code><code class="descname">LogNormalDistributionSchema</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/distributions.html#LogNormalDistributionSchema"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.distributions.LogNormalDistributionSchema" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.distributions.NormalDistributionSchema</span></code></p>
<p>Same parameters as Normal</p>
<p>keep in its own class since serialize/deserialize automatically
looks for this class name. Helps keep things consistent.</p>
</dd></dl>

<span class="target" id="module-gnome.utilities.serializable"></span><p>Created on Feb 15, 2013</p>
<dl class="class">
<dt id="gnome.utilities.serializable.Field">
<em class="property">class </em><code class="descclassname">gnome.utilities.serializable.</code><code class="descname">Field</code><span class="sig-paren">(</span><em>name</em>, <em>isdatafile=False</em>, <em>update=False</em>, <em>save=False</em>, <em>read=False</em>, <em>save_reference=False</em>, <em>iscollection=False</em>, <em>test_for_eq=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class containing information about the property to be serialized</p>
<p>Constructor for the Field object.
The Field object is used to describe the property of an object.
For instance, if a property is required to re-create the object from
a persisted _state, its &#8216;save&#8217; attribute is True.
If the property describes a data file that will need to be moved
when persisting the model, isdatafile should be True.
The gnome.persist.scenario module contains a Scenario class that loads
and saves a model. It looks for these attributes to correctly save/load
it.</p>
<p>It sets all attributes to False by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Name of the property being described by this Field
object</li>
<li><strong>isdatafile=False</strong> (<em>bool</em>) &#8211; Is the property a datafile that should be
moved during persistence?</li>
<li><strong>update=False</strong> (<em>bool</em>) &#8211; Is the property update-able by the web app?</li>
<li><strong>save=False</strong> (<em>bool</em>) &#8211; Is the property required to re-create the
object when loading from a save file?</li>
<li><strong>read=False</strong> (<em>bool</em>) &#8211; If property is not updateable, perhaps make it
read only so web app has information about the object</li>
<li><strong>save_reference=False</strong> (<em>bool</em>) &#8211; <p>bool with default value of False.
if the property is object, you can either
serialize the object and store it as a nested structure or just
store a reference to the object. For instance, the WindMover
contains a Wind object and a Weatherer could also contain the
same wind object, in this case, the &#8216;wind&#8217; property should be
stored as a reference. The Model.load function is responsible for
hooking up the correct Wind object to the WindMover, Weatherer etc</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">save_reference currently is only used when the field is
stored with &#8216;save&#8217; flag.</p>
</div>
</li>
<li><strong>iscollection=True</strong> (<em>bool</em>) &#8211; bool with default value of True
If the property is a collection (list, tuple, ordered collection),
we will need to special-case treat it.</li>
<li><strong>test_for_eq=True</strong> (<em>bool</em>) &#8211; bool with default value of True
when checking equality (__eq__()) of two gnome
objects that are serializable, look for equality of attributes
corresponding with fields with &#8216;save&#8217;=True and &#8216;test_for_eq&#8217;=True
For instance, if a gnome.model.Model() object is saved, then loaded
back from save file location, the filename attributes of objects
that read data from file will point to different location. The
objects are still equal. To avoid this problem, we can customize
whether to use a field when testing for equality or not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gnome.utilities.serializable.Serializable">
<em class="property">class </em><code class="descclassname">gnome.utilities.serializable.</code><code class="descname">Serializable</code><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">gnome.gnomeobject.GnomeId</span></code>, <code class="xref py py-class docutils literal"><span class="pre">gnome.persist.save_load.Savable</span></code></p>
<p>contains the to_dict and update_from_dict method to output properties of
object in a list.</p>
<p>This class is intended as a mixin so to_dict and update_from_dict become
part of the object and the object must define a _state attribute of type
State().</p>
<p>It mixes in the GnomeId class since all Serializable gnome objects will
have an Id as well</p>
<p>The default _state=State(save=[&#8216;id&#8217;]) is a static variable for this class
It uses the same convention as State to obtain the lists, &#8216;update&#8217; for
updating  properties, &#8216;read&#8217; for read-only properties and &#8216;save&#8217; for a
list of properties required to create new object.</p>
<p>The default _state contains &#8216;id&#8217; in the save list. This is because all
objects in a Model need &#8216;id&#8217; to create a new one.</p>
<p>Similarly, &#8216;obj_type&#8217; is required for all objects, this is so the scenario
module knows which object to create when loading from file.
A default implementation of obj_type_to_dict exists here.</p>
<p>Used obj_type instead of type because type is a builtin in python and
didn&#8217;t want to use the same name. The obj_type contains the type of the
object as a string.</p>
<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.new_from_dict">
<em class="property">classmethod </em><code class="descname">new_from_dict</code><span class="sig-paren">(</span><em>dict_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.new_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.new_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new object from dictionary</p>
<p>This is base implementation and can be over-ridden by classes using
this mixin</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary containing the serialized representation of this
object.</p>
<p>For every field, if there is a method defined on the object such that
the method name is <cite>{field_name}_to_dict</cite>, use the return value of that
method as the field value.</p>
<p>Note: any field in <cite>list</cite> that does not exist on the
object and does not have a to_dict method will raise an AttributeError.</p>
<p>NOTE: add the json_=&#8217;webapi&#8217; key to be serialized so we know what the
serialization is for</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.attr_to_dict">
<code class="descname">attr_to_dict</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.attr_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.attr_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>refactor to_dict&#8217;s functionality so child classes can convert a
single attribute to_dict instead of doing a whole list of fields</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.update_from_dict">
<code class="descname">update_from_dict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.update_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.update_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of this object using the dictionary <code class="docutils literal"><span class="pre">data</span></code> by
looking up the value of each key in <code class="docutils literal"><span class="pre">data</span></code>.
The fields in self._state that have update=True are modified. The
remaining keys in &#8216;data&#8217; are ignored. The object&#8217;s _state attribute
defines what fields can be updated</p>
<p>If an attribute has changed, then call &#8216;update_attr&#8217; to update its
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dict</em>) &#8211; dict containing state of object per the client</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if something changed, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not do updates on nested objects. If the attribute references
another Serializable object, then the value is not a dict but
rather the updated object. For instance, WindMover will receive:</p>
<blockquote>
<div>{..., &#8216;wind&#8217;: &lt;Wind object&gt;}</div></blockquote>
<p class="last">as opposed to a nested dict of the &#8216;wind&#8217; object. It is expected
that the &#8216;wind&#8217; object was updated by calling its own
update_from_dict then added to this dict as the updated object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.update_attr">
<code class="descname">update_attr</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.update_attr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.update_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>update the attribute defined by &#8216;name&#8217; with given &#8216;value&#8217;</p>
<p>If there is a method defined on the object such that the method name is
<cite>{name}_from_dict</cite>, call that method with the field&#8217;s data.</p>
<p>If neither method exists, then set the field with the value from
<code class="docutils literal"><span class="pre">data</span></code> directly on the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; name of attribute to be updated</li>
<li><strong>value</strong> (<em>depends on each attribute being updated</em>) &#8211; the new value of the attribute</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.obj_type_to_dict">
<code class="descname">obj_type_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.obj_type_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.obj_type_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>returns object type to save in dict.
This is base implementation and can be over-ridden</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.to_serialize">
<code class="descname">to_serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.to_serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.to_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke to_dict() which converts all attributes defined in _state to
dict.
If json_=&#8217;save&#8217;, it subselects the Fields with save=True.
If json_=&#8217;webapi&#8217;, it subselects Fields with (update=True, read=True)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.serialize">
<code class="descname">serialize</code><span class="sig-paren">(</span><em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the dict returned by object&#8217;s to_dict method to valid json
format via colander schema</p>
<p>It uses the modules_dict defined in gnome.persist to find the correct
schema module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> &#8211; tells object whether serialization is for web content
or for generating a save file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">json format of serialized data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.is_sparse">
<em class="property">classmethod </em><code class="descname">is_sparse</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.is_sparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.is_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse means that we have a previously created object,
and we are receiving a reference to the object using just
an obj_type and an id.  This is a valid payload that the
Web Client will send.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.serializable.Serializable.serialize_oc">
<code class="descname">serialize_oc</code><span class="sig-paren">(</span><em>coll</em>, <em>json_='webapi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.serialize_oc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.serialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Model attributes of type ordered collection or list - an
iterable containing serializable objects</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.deserialize">
<em class="property">classmethod </em><code class="descname">deserialize</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.deserialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.deserialize" title="Permalink to this definition">¶</a></dt>
<dd><p>classmethod takes json structure as input, deserializes it using a
colander schema then invokes the new_from_dict method to create an
instance of the object described by the json schema.</p>
<p>We also need to accept sparse json objects, in which case we will
not treat them, but just send them back.</p>
</dd></dl>

<dl class="classmethod">
<dt id="gnome.utilities.serializable.Serializable.deserialize_oc">
<em class="property">classmethod </em><code class="descname">deserialize_oc</code><span class="sig-paren">(</span><em>json_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/serializable.html#Serializable.deserialize_oc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.serializable.Serializable.deserialize_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>check contents of orderered collections to figure out what schema to
use.
Basically, the json serialized ordered collection looks like a regular
list.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-gnome.utilities.orderedcollection"></span><dl class="class">
<dt id="gnome.utilities.orderedcollection.OrderedCollection">
<em class="property">class </em><code class="descclassname">gnome.utilities.orderedcollection.</code><code class="descname">OrderedCollection</code><span class="sig-paren">(</span><em>elems=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Generalized Container for a set of objects of a particular type which
preserves the order of insertion and supports replacement of not only
an object in the list, but the key/id that references it. (a normal
OrderedDict can&#8217;t do this)
- The order of insertion is preserved.
- Objects are accessed by id, as if in a dictionary.
- Objects can be replaced in order.  The objects will be referenced
by a new id, and still be in the correct order.</p>
<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.remake">
<code class="descname">remake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.remake"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.remake" title="Permalink to this definition">¶</a></dt>
<dd><p>remove None elements from self._elems and renumber the indices in
self._d_index</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>ident</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.get" title="Permalink to this definition">¶</a></dt>
<dd><p>can get the object either by &#8216;id&#8217; or by index in the order in which
it was added</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an object to the collection</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>ident</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an object from the collection:
1) can remove by index (similar to a list)
2) can remove by id of object (similar to a dict)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>ident</em>, <em>new_elem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace an object in the collection:
1) replace by index (similar to a list)
2) replace by id of object (similar to a dict)</p>
<p>raise exception if &#8216;id&#8217; is not found.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.index" title="Permalink to this definition">¶</a></dt>
<dd><p>acts like index method in a list.
It returns the index associated with self._elems[index] = elem
It can also take the &#8216;id&#8217; as input and returns the index of the object
in the list</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Method takes the instance of ordered collection and outputs a list of
dicts, each with two fields:</p>
<div class="highlight-python"><div class="highlight"><pre>{obj_type: object type &lt;module.class&gt;,
id: IDs of each object}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.register_callback">
<code class="descname">register_callback</code><span class="sig-paren">(</span><em>callback</em>, <em>events=('add'</em>, <em>'replace'</em>, <em>'remove')</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.register_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>callbacks registered for following events:
- add: item is added
- replace:
- remove: callback invoked after removing the item</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear all elements from collection</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.orderedcollection.OrderedCollection.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/orderedcollection.html#OrderedCollection.values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.orderedcollection.OrderedCollection.values" title="Permalink to this definition">¶</a></dt>
<dd><p>return list of items contained in collection</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-gnome.utilities.map_canvas"></span><p>Module to hold classes and suporting code for the map canvas for GNOME:</p>
<p>The drawing code for rendering to images in scripting mode, and also for
pushing some rendering to the server.</p>
<p>Also used for making raster maps.</p>
<p>This should have the basic drawing stuff. Ideally nothig in here is
GNOME-specific.</p>
<p>This version used libgd and py_gd instead of PIL for the rendering</p>
<dl class="class">
<dt id="gnome.utilities.map_canvas.MapCanvas">
<em class="property">class </em><code class="descclassname">gnome.utilities.map_canvas.</code><code class="descname">MapCanvas</code><span class="sig-paren">(</span><em>image_size</em>, <em>projection=None</em>, <em>viewport=None</em>, <em>preset_colors='BW'</em>, <em>background_color='transparent'</em>, <em>colordepth=8</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A class to draw maps, etc.</p>
<p>This class provides the ability to set a projection, and then
change the viewport of the rendered map</p>
<p>All the drawing methods will project and scale and shift the points so the
rendered image is projected and shows only what is in the viewport.</p>
<p>In addition, it keeps two image buffers: background and foreground. These
can be rendered individually, and saved out either alone or composited.</p>
<p>This version uses a paletted (8 bit) image &#8211; may be updated for RGB images
at some point.</p>
<p>create a new map image from scratch &#8211; specifying the size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image_size</strong> &#8211; (width, height) tuple of the image size in pixels</td>
</tr>
</tbody>
</table>
<p>Optional parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>projection=None</strong> &#8211; gnome.utilities.projections object to use.
if None, it defaults to FlatEarthProjection()</li>
<li><strong>viewport</strong> &#8211; viewport of map &#8211; what gets drawn and on what
scale.
Default is full globe: (((-180, -90), (180, 90)))</li>
<li><strong>preset_colors='BW'</strong> &#8211; <p>color set to preset. Options are:</p>
<dl class="docutils">
<dt>&#8216;BW&#8217; - transparent, black, and white:</dt>
<dd>transparent background</dd>
<dt>&#8216;web&#8217; - the basic named colors for the web:</dt>
<dd>transparent background</dd>
<dt>&#8216;transparent&#8217; - transparent background,</dt>
<dd>no other colors set</dd>
<dt>None - no pre-allocated colors</dt>
<dd><dl class="first last docutils">
<dt>&#8211; the first one you allocate will</dt>
<dd>be the background color</dd>
</dl>
</dd>
</dl>
</li>
<li><strong>= 'transparent'</strong> (<em>background_color</em>) &#8211; color for the background
&#8211; must be a color that exists</li>
<li><strong>colordepth=8</strong> &#8211; only 8 bit color supported for now
maybe someday, 32 bit will be an option</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.viewport_to_dict">
<code class="descname">viewport_to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.viewport_to_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.viewport_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>convert numpy arrays to list of tuples
todo: this happens in multiple places so maybe worthwhile to define
custom serialize/deserialize &#8211; but do this for now</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.utilities.map_canvas.MapCanvas.viewport">
<code class="descname">viewport</code><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the current value of viewport of map:
the bounding box of the image</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.set_viewport">
<code class="descname">set_viewport</code><span class="sig-paren">(</span><em>BB=None</em>, <em>center=None</em>, <em>width=None</em>, <em>height=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.set_viewport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.set_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to allow the user to set properties of the viewport in meters,
or by bounding box</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>center</strong> &#8211; The point around which the viewport is centered</td>
</tr>
</tbody>
</table>
<p>:type a tuple containing an x/y coordinate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>width</strong> &#8211; Width of the viewport in meters</li>
<li><strong>height</strong> &#8211; height of the viewport in meters</li>
<li><strong>BB</strong> &#8211; Bounding box of the viewport
(overrides all previous parameters)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:type a list of tuples containing of the lower left and top right</dt>
<dd>coordinates</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.rescale">
<code class="descname">rescale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.rescale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales the projection to the viewport bounding box.
Should be called whenever the viewport changes</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.utilities.map_canvas.MapCanvas.image_size">
<code class="descname">image_size</code><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.image_size" title="Permalink to this definition">¶</a></dt>
<dd><p>makes it read-only</p>
<p>or we can add a setter to re-size the images if we need that</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.add_colors">
<code class="descname">add_colors</code><span class="sig-paren">(</span><em>color_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.add_colors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.add_colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of colors to the pallette</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>color_list</strong> &#8211; <p>list of colors
- each elemnt of the list is a 2-tuple:</p>
<blockquote>
<div>(&#8216;color_name&#8217;, (r,g,b))</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.get_color_names">
<code class="descname">get_color_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.get_color_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.get_color_names" title="Permalink to this definition">¶</a></dt>
<dd><p>returns all the names colors</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.back_asarray">
<code class="descname">back_asarray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.back_asarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.back_asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>return the background image as a numpy array</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.fore_asarray">
<code class="descname">fore_asarray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.fore_asarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.fore_asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>return the foreground image as a numpy array</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.copy_back_to_fore">
<code class="descname">copy_back_to_fore</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.copy_back_to_fore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.copy_back_to_fore" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the background to the foreground</p>
<p>note: this will write over anything on the foreground image</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.draw_points">
<code class="descname">draw_points</code><span class="sig-paren">(</span><em>points</em>, <em>diameter=1</em>, <em>color='black'</em>, <em>shape='round'</em>, <em>background=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.draw_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.draw_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a set of individual points all in the same color</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points</strong> &#8211; a Nx2 numpy array, or something that can be turned
into one</li>
<li><strong>diameter=1</strong> &#8211; diameter of the points in pixels.</li>
<li><strong>color</strong> (<em>string</em>) &#8211; a named color.</li>
<li><strong>shape</strong> (<em>string</em>) &#8211; what shape to draw, options are &#8220;round&#8221;, &#8220;x&#8221;.</li>
<li><strong>background=False</strong> &#8211; whether to draw to the background image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.draw_polygon">
<code class="descname">draw_polygon</code><span class="sig-paren">(</span><em>points</em>, <em>line_color=None</em>, <em>fill_color=None</em>, <em>line_width=1</em>, <em>background=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.draw_polygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.draw_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a polygon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points</strong> (<em>Nx2 array of integers (or something that can be turned
into one)</em>) &#8211; sequence of points</li>
<li><strong>line_color=None</strong> (<em>color name (string) or index (int)</em>) &#8211; the color of the outline</li>
<li><strong>fill_color=None</strong> &#8211; the color of the filled polygon</li>
<li><strong>line_width=1</strong> &#8211; width of line</li>
<li><strong>background=False</strong> &#8211; whether to draw to the background image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.draw_polyline">
<code class="descname">draw_polyline</code><span class="sig-paren">(</span><em>points</em>, <em>line_color</em>, <em>line_width=1</em>, <em>background=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.draw_polyline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.draw_polyline" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a polyline</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points</strong> (<em>Nx2 array of integers (or something that can be turned
into one)</em>) &#8211; sequence of points</li>
<li><strong>line_color</strong> (<em>color name or index</em>) &#8211; the color of the outline</li>
<li><strong>line_width=1</strong> &#8211; width of line</li>
<li><strong>background=False</strong> &#8211; whether to draw to the background image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.draw_text">
<code class="descname">draw_text</code><span class="sig-paren">(</span><em>text_list</em>, <em>size='small'</em>, <em>color='black'</em>, <em>align='lt'</em>, <em>background='none'</em>, <em>draw_to_back=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.draw_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.draw_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw ascii text to the image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text_list</strong> (<em>[&#8216;string&#8217;, (lon, lat)]</em>) &#8211; sequence of strings to be printed, and the locations
they are to be located</li>
<li><strong>size</strong> (<em>one of the following strings:
{&#8216;tiny&#8217;, &#8216;small&#8217;, &#8216;medium&#8217;, &#8216;large&#8217;, &#8216;giant&#8217;}</em>) &#8211; size of the text to be printed</li>
<li><strong>color</strong> (<em>a valid color string in the py_gd Image color palettes</em>) &#8211; color of the text to be printed</li>
<li><strong>align</strong> (<em>one of the following strings:
{&#8216;lt&#8217;, &#8216;ct&#8217;, &#8216;rt&#8217;, &#8216;r&#8217;, &#8216;rb&#8217;, &#8216;cb&#8217;, &#8216;lb&#8217;, &#8216;l&#8217;}</em>) &#8211; sets the principal point of the text bounding box.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.draw_graticule">
<code class="descname">draw_graticule</code><span class="sig-paren">(</span><em>background=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.draw_graticule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.draw_graticule" title="Permalink to this definition">¶</a></dt>
<dd><p>draw a graticule (grid lines) on the map</p>
<p>only supports decimal degrees for now...</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.MapCanvas.save_foreground">
<code class="descname">save_foreground</code><span class="sig-paren">(</span><em>filename</em>, <em>file_type='png'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#MapCanvas.save_foreground"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.MapCanvas.save_foreground" title="Permalink to this definition">¶</a></dt>
<dd><p>save the foreground image to the specified filename</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; full path of file to be saved to</li>
<li><strong>draw_back_to_fore=True</strong> &#8211; whether to add the background image
to the foreground before saving.</li>
<li><strong>file_type</strong> (<em>one of the following:
{&#8216;png&#8217;, &#8216;gif&#8217;, &#8216;jpeg&#8217;, &#8216;bmp&#8217;}</em>) &#8211; type of file to save</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.utilities.map_canvas.GridLines">
<em class="property">class </em><code class="descclassname">gnome.utilities.map_canvas.</code><code class="descname">GridLines</code><span class="sig-paren">(</span><em>viewport=None</em>, <em>projection=None</em>, <em>max_lines=10</em>, <em>DegMinSec=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>class to hold logic for determining where the gridlines should be
for the graticule</p>
<p>Creates a GridLines instance that does the logic for and describes
the current graticule</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>viewport</strong> (<em>tuple of lon/lat</em>) &#8211; bounding box of the viewport in question.</li>
<li><strong>max_lines</strong> (<em>tuple of integers, (max, min)</em>) &#8211; How many lines to be displayed on the longest
dimension of the viewport. Graticule will scale up
or down only when the number of lines in the viewport
falls outside the range.</li>
<li><strong>DegMinSec</strong> &#8211; Whether to scale by Degrees/Minute/Seconds,
or decimal lon/lat</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:type bool</p>
<dl class="method">
<dt id="gnome.utilities.map_canvas.GridLines.get_step_size">
<code class="descname">get_step_size</code><span class="sig-paren">(</span><em>reference_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines.get_step_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines.get_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Chooses the interval size for the graticule, based on where the
reference size fits into the STEPS table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reference_size</strong> &#8211; the approximate size you want in decimal degrees</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.GridLines.get_lines">
<code class="descname">get_lines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines.get_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines.get_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes, builds, and returns a list of lines that when drawn,
creates the graticule.
The list consists of self.lon_lines vertical lines,
followed by self.lat_lines horizontal lines.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.GridLines.refresh_scale">
<code class="descname">refresh_scale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines.refresh_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines.refresh_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Recomputes the interval and number of lines in each dimension.
This should be called whenever the viewport changes.</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.GridLines.set_max_lines">
<code class="descname">set_max_lines</code><span class="sig-paren">(</span><em>max_lines=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines.set_max_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines.set_max_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the number of lines drawn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_lines</strong> (<em>int</em>) &#8211; <p>the maximum number of lines drawn.
(Note: this is NOT the number of lines on the screen</p>
<blockquote>
<div>at any given time.  That is determined by
the computed interval and the size/location
of the viewport)</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.GridLines.set_DMS">
<code class="descname">set_DMS</code><span class="sig-paren">(</span><em>DMS=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines.set_DMS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines.set_DMS" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>DMS</strong> (<em>Bool</em>) &#8211; Boolean value that specifies if Degrees/Minutes/Seconds
tags are enabled.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.map_canvas.GridLines.get_tags">
<code class="descname">get_tags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#GridLines.get_tags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.GridLines.get_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of tags for each line (in the same order the lines
are returned) and the position where the tag should be printed.</p>
<p>Line labels are anchored at the intersection between the line and the
edge of the viewport. This may cause the longitude labels to disappear
if the aspect ratio of the image and viewport are identical.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.utilities.map_canvas.Viewport">
<em class="property">class </em><code class="descclassname">gnome.utilities.map_canvas.</code><code class="descname">Viewport</code><span class="sig-paren">(</span><em>BB=None</em>, <em>center=None</em>, <em>width=None</em>, <em>height=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/map_canvas.html#Viewport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.map_canvas.Viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>class that defines and manages attribues for a viewport onto a flat 2D map.
All points and measurements are in lon/lat</p>
<p>Init the viewport.
Can initialize with center/width/height, and/or with bounding box.
NOTE: Bounding box takes precedence over any previous parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>center</strong> &#8211; The point around which the viewport is centered</td>
</tr>
</tbody>
</table>
<p>:type a tuple containing an lon/lat coordinate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>width</strong> &#8211; Width of the viewport (lon)</li>
<li><strong>height</strong> &#8211; height of the viewport (lat)</li>
<li><strong>BB</strong> &#8211; Bounding box of the viewport (overrides previous parameters)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:type a list of lon/lat tuples containing the lower left and top right</dt>
<dd>coordinates</dd>
</dl>
</dd></dl>

<span class="target" id="module-gnome.utilities.projections"></span><p>Module to hold classes and supporting code for projections used in GNOME.</p>
<p>Only:</p>
<blockquote>
<div><ul class="simple">
<li>no projection</li>
<li>geo-projection (just scaling to pixels)</li>
<li>a simple &#8220;flat earth&#8221; projection for</li>
</ul>
</div></blockquote>
<p>Also a bit of code for scaling lat-long to meters, etc.</p>
<p>Used by map_canvas code and map code.</p>
<dl class="docutils">
<dt>NOTE: all coordinates are takes as (lon, lat, depth)</dt>
<dd>even though depth is always ignored</dd>
</dl>
<dl class="class">
<dt id="gnome.utilities.projections.NoProjection">
<em class="property">class </em><code class="descclassname">gnome.utilities.projections.</code><code class="descname">NoProjection</code><span class="sig-paren">(</span><em>bounding_box=None</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#NoProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.NoProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This is do-nothing projection class &#8211; returns what it gets.</p>
<p>It optionally rounds down to integer (pixel) coordinates</p>
<p>used for testing, primarily, and as a definition of the interface</p>
<p>create a new do-nothing projection</p>
<dl class="method">
<dt id="gnome.utilities.projections.NoProjection.set_scale">
<code class="descname">set_scale</code><span class="sig-paren">(</span><em>bounding_box</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#NoProjection.set_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.NoProjection.set_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Does nothing</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.NoProjection.to_pixel">
<code class="descname">to_pixel</code><span class="sig-paren">(</span><em>coords</em>, <em>asint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#NoProjection.to_pixel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.NoProjection.to_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the same (lon, lat) coords, but as an np.array, if they aren&#8217;t already</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coords</strong> &#8211; &#8211; the coords to project (Nx3 numpy array or compatible sequence)
(lon, lat, depth)</li>
<li><strong>asint</strong> &#8211; &#8211; flag to set whether to convert to a integer or not
default is to leave it as the same type it came in,
so you can have fractional pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.NoProjection.to_pixel_2D">
<code class="descname">to_pixel_2D</code><span class="sig-paren">(</span><em>coords</em>, <em>asint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#NoProjection.to_pixel_2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.NoProjection.to_pixel_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>same as to_pixel, but expects only (lon, lat) coords as input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coords</strong> &#8211; &#8211; the coords to project
(Nx2 numpy array or compatible sequence)
(lon, lat)</li>
<li><strong>asint</strong> &#8211; &#8211; flag to set whether to convert to a integer or not
default is to leave it as the same type it came in,
so you can have fractional pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.NoProjection.to_lonlat">
<code class="descname">to_lonlat</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#NoProjection.to_lonlat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.NoProjection.to_lonlat" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the same coords, but as a np.array of float64,
if they aren&#8217;t already</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.utilities.projections.GeoProjection">
<em class="property">class </em><code class="descclassname">gnome.utilities.projections.</code><code class="descname">GeoProjection</code><span class="sig-paren">(</span><em>bounding_box=None</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#GeoProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.GeoProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This acts as the base class for a projection</p>
<p>This one doesn&#8217;t really project, but does convert to pixel coords
i.e. &#8220;geo-coordinates&#8221;</p>
<p>create a new projection</p>
<p>Projection(bounding_box, image_size)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bounding_box</strong> &#8211; <p>the bounding box of the map:
( (min_long, min_lat),</p>
<blockquote>
<div>(max_lon,  max_lat) )</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>(or a BoundingBox Object)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image_size</strong> &#8211; the size of the map image &#8211; (width, height)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.utilities.projections.GeoProjection.set_scale">
<code class="descname">set_scale</code><span class="sig-paren">(</span><em>bounding_box</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#GeoProjection.set_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.GeoProjection.set_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>set the scaling, etc. of the projection</p>
<p>This should be called whenever the bounding box of the map,
or the size of the image is changed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bounding_box</strong> &#8211; <p>bounding box of the visual portion of the map
in the form:  ( (min_long, min_lat),</p>
<blockquote>
<div>(max_long, max_lat) )</div></blockquote>
</li>
<li><strong>image_size=None</strong> &#8211; the size of the image that will be drawn to.
if not given, the previous size will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.GeoProjection.to_pixel">
<code class="descname">to_pixel</code><span class="sig-paren">(</span><em>coords</em>, <em>asint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#GeoProjection.to_pixel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.GeoProjection.to_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>converts input coordinates to pixel coords</p>
<p>param: coords &#8211;  an array of coordinates &#8211; NX3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span> <span class="p">(</span><span class="n">long1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">z1</span><span class="p">),</span>
  <span class="p">(</span><span class="n">long2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">z2</span><span class="p">),</span>
  <span class="p">(</span><span class="n">long3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">,</span> <span class="n">z3</span><span class="p">),</span>
   <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>(z is ignored, and there is no z in the returned array)</p>
<p>returns:  the pixel coords as a similar Nx2 array of integer x,y coordinates
(using the y = 0 at the top, and y increasing down)</p>
<dl class="docutils">
<dt>NOTE: the values between the minimum of a pixel value to less than the</dt>
<dd>max of a pixel range are in that pixel, so  a point exactly at
the minimum of the bounding box will be in the zeroth pixel, but
a point  exactly at the max of the bounding box will be considered
outside the map</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.GeoProjection.to_pixel_2D">
<code class="descname">to_pixel_2D</code><span class="sig-paren">(</span><em>coords</em>, <em>asint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#GeoProjection.to_pixel_2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.GeoProjection.to_pixel_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>same as to_pixel, but expects only (lon, lat) coords as input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coords</strong> &#8211; &#8211; the coords to project
(Nx2 numpy array or compatible sequence)
(lon, lat)</li>
<li><strong>asint</strong> &#8211; &#8211; flag to set whether to convert to a integer or not
default is to leave it as the same type it came in,
so you can have fractional pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.GeoProjection.to_lonlat">
<code class="descname">to_lonlat</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#GeoProjection.to_lonlat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.GeoProjection.to_lonlat" title="Permalink to this definition">¶</a></dt>
<dd><p>converts pixel coords to long-lat coords</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> &#8211; <ul>
<li>an array of pixel coordinates (usually integer type)
NX2: ( (long1, lat1),<blockquote>
<div><blockquote>
<div><blockquote>
<div>(long2, lat2),
(long3, lat3),</div></blockquote>
</div></blockquote>
<p>)</p>
</div></blockquote>
</li>
</ul>
<p>(as produced by to_pixel)</p>
</td>
</tr>
</tbody>
</table>
<p>NOTE: there is not depth in input &#8211; pixels are always 2-d!</p>
<p>Note that  to_lonlat( to_pixel (coords) ) != coords, due to rounding.
If the input is integers, a 0.5 is added to &#8220;shift&#8221; the location to mid-pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the pixel coords as a similar Nx2 array of floating point x,y coordinates</td>
</tr>
</tbody>
</table>
<p>(using the y = 0 at the top, and y increasing down)</p>
<p>Note that  to_lonlat( to_pixel (coords) ) != coords, due to rounding.
If the input is integers, a 0.5 is added to &#8220;shift&#8221; the location to
mid-pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the pixel coords as a similar Nx2 array of floating point
x,y coordinates (using the y = 0 at the top, and y increasing down)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.utilities.projections.FlatEarthProjection">
<em class="property">class </em><code class="descclassname">gnome.utilities.projections.</code><code class="descname">FlatEarthProjection</code><span class="sig-paren">(</span><em>bounding_box=None</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#FlatEarthProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.FlatEarthProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.utilities.projections.GeoProjection" title="gnome.utilities.projections.GeoProjection"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.projections.GeoProjection</span></code></a></p>
<p>class to define a &#8220;flat earth&#8221; projection:</p>
<blockquote>
<div><p>longitude is scaled to the cosine of the mid-latitude &#8211; but that&#8217;s it.</p>
<p>not conforming to equal area, distance, bearing, or any other nifty
map properties &#8211; but easy to compute, and it looks OK.</p>
</div></blockquote>
<p>create a new projection</p>
<p>Projection(bounding_box, image_size)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bounding_box</strong> &#8211; <p>the bounding box of the map:
( (min_long, min_lat),</p>
<blockquote>
<div>(max_lon,  max_lat) )</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>(or a BoundingBox Object)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image_size</strong> &#8211; the size of the map image &#8211; (width, height)</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="gnome.utilities.projections.FlatEarthProjection.meters_to_lonlat">
<em class="property">static </em><code class="descname">meters_to_lonlat</code><span class="sig-paren">(</span><em>meters</em>, <em>ref_positions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#FlatEarthProjection.meters_to_lonlat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.FlatEarthProjection.meters_to_lonlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from delta meters to delta latitude-longitude, using the Flat-Earth projection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>meters</strong> &#8211; NX3 numpy array of (dx, dy, dz) distances in meters (dz is passed through untouched)</li>
<li><strong>ref_positions</strong> &#8211; NX3, numpy array of reference positions in degrees (Only lat is used here)</li>
<li><strong>meters</strong> &#8211; NX3 numpy array of (dx, dy, dz) distances in meters
(dz is passed through untouched)</li>
<li><strong>ref_positions</strong> &#8211; NX3, numpy array of reference positions
in degrees (Only lat is used here)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Returns delta_lon_lat:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">Nx3 numpy array of
(delta-lon, delta-lat, delta-z) triples</p>
</td>
</tr>
</tbody>
</table>
<p>dlat = dy * 8.9992801e-06
dlon = dy * 8.9992801e-06 * cos(ref_lat)
(based on previous GNOME value: and/or average radius of the earth of</p>
<blockquote>
<div>6366706.989  m)</div></blockquote>
</dd></dl>

<dl class="staticmethod">
<dt id="gnome.utilities.projections.FlatEarthProjection.lonlat_to_meters">
<em class="property">static </em><code class="descname">lonlat_to_meters</code><span class="sig-paren">(</span><em>lon_lat</em>, <em>ref_positions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#FlatEarthProjection.lonlat_to_meters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.FlatEarthProjection.lonlat_to_meters" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from delta longitude-latitude to delta meters, using the
Flat-Earth projection. This should be a reversal of meters_to_latlon.</p>
<p>This function mainly used for testing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lon_lat</strong> &#8211; NX3 numpy array of (dlon, dlat, dz) distances in meters
(dz is passed through untouched)</li>
<li><strong>ref_positions</strong> &#8211; NX3, numpy array of (lon,lat,z)
reference positions in degrees
(Only lat is used here)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Returns delta_meters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">Nx3 numpy array of (delta-x, delta-y, delta-z)
triples</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>NOTE: the input is in units of longitude and latitude, but they are</dt>
<dd>relative &#8211; no absolute &#8211; so 0 means zero distance,
not on the equator</dd>
</dl>
<p>dy = dlon / 8.9992801e-06
dx = dlat / ( 8.9992801e-06 * cos(ref_lat) )</p>
<p>(based on previous GNOME value: and/or average radius of the earth of 6366706.989  m)</p>
</dd></dl>

<dl class="staticmethod">
<dt id="gnome.utilities.projections.FlatEarthProjection.geodesic_sphere">
<em class="property">static </em><code class="descname">geodesic_sphere</code><span class="sig-paren">(</span><em>lon</em>, <em>lat</em>, <em>distance</em>, <em>bearing</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#FlatEarthProjection.geodesic_sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.FlatEarthProjection.geodesic_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a start point, initial bearing, and distance, returns the
destination point along a (shortest distance) great circle arc &#8211;
assuming a spherical earth. Similar to how GNOME does it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lon</strong> &#8211; longitude in decimal degrees.</li>
<li><strong>lat</strong> &#8211; latitude in decimal degrees.</li>
<li><strong>distance</strong> &#8211; meters.</li>
<li><strong>bearing</strong> &#8211; in decimal degrees, measured clockwise from north.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Returns longitude, latitude:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">in degrees.</p>
</td>
</tr>
</tbody>
</table>
<p>Code from Brian Zelenke</p>
<p>NOTE: performance could be improved a lot here if need be (lots of data copies)</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.FlatEarthProjection.set_scale">
<code class="descname">set_scale</code><span class="sig-paren">(</span><em>bounding_box</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#FlatEarthProjection.set_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.FlatEarthProjection.set_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>set the scaling, etc. of the projection</p>
<p>This should be called whenever the bounding box of the map,
or the size of the image is changed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bounding_box</strong> &#8211; <p>bounding box of the visual portion of the map
in the form:  ( (min_long, min_lat),</p>
<blockquote>
<div>(max_long, max_lat) )</div></blockquote>
</li>
<li><strong>image_size=None</strong> &#8211; the size of the image that will be drawn to.
if not given, the previous size will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.utilities.projections.RectangularGridProjection">
<em class="property">class </em><code class="descclassname">gnome.utilities.projections.</code><code class="descname">RectangularGridProjection</code><span class="sig-paren">(</span><em>longitude</em>, <em>latitude</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RectangularGridProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RectangularGridProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.utilities.projections.NoProjection" title="gnome.utilities.projections.NoProjection"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.projections.NoProjection</span></code></a></p>
<p>projection for lat-lon to pixel and back for a rectangular but not regular
grid.</p>
<dl class="docutils">
<dt>i.e a rectangular grid that can be defined by a single vector each of</dt>
<dd>latitude and longitude</dd>
</dl>
<p>This is a totally different type of projection &#8211; it requires a linear
interpolation for the latitude and longitude.</p>
<p>Primarily used for making a raster land-water map from a non-regular
rectangular grid.</p>
<p>Create a new Rectangular Grid projection</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>longitude</strong> &#8211; the vector of longitudes</li>
<li><strong>latitude</strong> &#8211; the vector of latitudes</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>It is assumed that the largest and smallest
values define the bounds of the raster.</p>
<dl class="method">
<dt id="gnome.utilities.projections.RectangularGridProjection.set_scale">
<code class="descname">set_scale</code><span class="sig-paren">(</span><em>bounding_box</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RectangularGridProjection.set_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RectangularGridProjection.set_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Does nothing</p>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.RectangularGridProjection.to_pixel">
<code class="descname">to_pixel</code><span class="sig-paren">(</span><em>coords</em>, <em>asint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RectangularGridProjection.to_pixel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RectangularGridProjection.to_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the pixel coordintes in the gird for teh given lat-lon location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coords</strong> &#8211; &#8211; the coords to project (Nx3 numpy array or compatible sequence)
(lon, lat, depth)</li>
<li><strong>asint</strong> &#8211; &#8211; flag to set whether to convert to a integer or not
default is to leave it as the same type it came in,
so you can have fractional pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.RectangularGridProjection.to_pixel_2D">
<code class="descname">to_pixel_2D</code><span class="sig-paren">(</span><em>coords</em>, <em>asint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RectangularGridProjection.to_pixel_2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RectangularGridProjection.to_pixel_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>same as to_pixel, but expects only (lon, lat) coords as input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coords</strong> &#8211; &#8211; the coords to project
(Nx2 numpy array or compatible sequence)
(lon, lat)</li>
<li><strong>asint</strong> &#8211; &#8211; flag to set whether to convert to a integer or not
default is to leave it as the same type it came in,
so you can have fractional pixels</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.projections.RectangularGridProjection.to_lonlat">
<code class="descname">to_lonlat</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RectangularGridProjection.to_lonlat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RectangularGridProjection.to_lonlat" title="Permalink to this definition">¶</a></dt>
<dd><p>converts pixel coords to long-lat coords</p>
<dl class="docutils">
<dt>param: coords  - an array of pixel coordinates (usually integer type)</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>NX2: ( (long1, lat1),</dt>
<dd><blockquote class="first">
<div><blockquote>
<div>(long2, lat2),
(long3, lat3),</div></blockquote>
</div></blockquote>
<p class="last">)</p>
</dd>
</dl>
</div></blockquote>
<p class="last">(as produced by to_pixel)</p>
</dd>
</dl>
<p>NOTE: there is not depth in input &#8211; pixels are always 2-d!</p>
<p>Note that  to_lonlat( to_pixel (coords) ) != coords, due to rounding.
If the input is integers, a 0.5 is added to &#8220;shift&#8221; the location
to mid-pixel.
returns: the pixel coords as a similar Nx2 array of floating point</p>
<blockquote>
<div>x,y coordinates
(using the y = 0 at the top, and y increasing down)</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gnome.utilities.projections.RegularGridProjection">
<em class="property">class </em><code class="descclassname">gnome.utilities.projections.</code><code class="descname">RegularGridProjection</code><span class="sig-paren">(</span><em>bounding_box=None</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RegularGridProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RegularGridProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gnome.utilities.projections.GeoProjection" title="gnome.utilities.projections.GeoProjection"><code class="xref py py-class docutils literal"><span class="pre">gnome.utilities.projections.GeoProjection</span></code></a></p>
<p>projection for lat-lon to pixel and back for a pre-defined regular grid.</p>
<p>This differs from the other projections in that it doesn&#8217;t try to
match the bounding box aspect ratio &#8211; it simply uses the one
already defined by the grid.</p>
<p>You  could use a RectangularGridProjection here as well, but this is
simpler and should be faster.</p>
<p>create a new projection</p>
<p>Projection(bounding_box, image_size)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bounding_box</strong> &#8211; <p>the bounding box of the map:
( (min_long, min_lat),</p>
<blockquote>
<div>(max_lon,  max_lat) )</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>(or a BoundingBox Object)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image_size</strong> &#8211; the size of the map image &#8211; (width, height)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.utilities.projections.RegularGridProjection.set_scale">
<code class="descname">set_scale</code><span class="sig-paren">(</span><em>bounding_box</em>, <em>image_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/projections.html#RegularGridProjection.set_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.projections.RegularGridProjection.set_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>set the scaling, etc. of the projection</p>
<p>This should be called whenever the bounding box of the map,
or the size of the image is changed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bounding_box</strong> &#8211; <p>bounding box of the visual portion of the map
in the form:  ( (min_long, min_lat),</p>
<blockquote>
<div>(max_long, max_lat) )</div></blockquote>
</li>
<li><strong>image_size=None</strong> &#8211; the size of the image that will be drawn to.
if not given, the previous size will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-gnome.utilities.inf_datetime"></span><p>special datetime objects with -inf and inf times</p>
<p>These are not real datetime objects &#8211; simply something that can be compared
with one</p>
<p>Note: this is very liberal with comparisons &#8211; essentially an infinity
time object is greater than anything, so no checking to see what you are
comparing to..</p>
<p>Also special constructor for a real datetime that won&#8217;t allow values out of
range for this application</p>
<dl class="class">
<dt id="gnome.utilities.inf_datetime.InfTime">
<em class="property">class </em><code class="descclassname">gnome.utilities.inf_datetime.</code><code class="descname">InfTime</code><a class="reference internal" href="_modules/gnome/utilities/inf_datetime.html#InfTime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.inf_datetime.InfTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>class representing time into infinity</p>
<p>compares as greater than any datetime (or any other object..)</p>
</dd></dl>

<dl class="class">
<dt id="gnome.utilities.inf_datetime.MinusInfTime">
<em class="property">class </em><code class="descclassname">gnome.utilities.inf_datetime.</code><code class="descname">MinusInfTime</code><a class="reference internal" href="_modules/gnome/utilities/inf_datetime.html#MinusInfTime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.inf_datetime.MinusInfTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>class representing time from infinity in the past</p>
<p>compares as less than any datetime (or any other object)</p>
</dd></dl>

<dl class="class">
<dt id="gnome.utilities.inf_datetime.InfDateTime">
<em class="property">class </em><code class="descclassname">gnome.utilities.inf_datetime.</code><code class="descname">InfDateTime</code><a class="reference internal" href="_modules/gnome/utilities/inf_datetime.html#InfDateTime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.inf_datetime.InfDateTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">datetime.datetime</span></code></p>
<p>A special datetime object:</p>
<p>It is either a regular datetime object, with the provisio
that it can&#8217;t be set outside the range given by the module
variables:</p>
<p>min_datetime
max_datetime</p>
<p>or a MinusInfTime or InfTime object.</p>
</dd></dl>

<span class="target" id="module-gnome.utilities.cache"></span><p>cache system for caching element data on disk for
accessing again for output, etc.</p>
<dl class="exception">
<dt id="gnome.utilities.cache.CacheError">
<em class="property">exception </em><code class="descclassname">gnome.utilities.cache.</code><code class="descname">CacheError</code><a class="reference internal" href="_modules/gnome/utilities/cache.html#CacheError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.cache.CacheError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Here so we can be sure the user knows the error is coming from here</p>
</dd></dl>

<dl class="function">
<dt id="gnome.utilities.cache.clean_up_cache">
<code class="descclassname">gnome.utilities.cache.</code><code class="descname">clean_up_cache</code><span class="sig-paren">(</span><em>dir_name='/var/folders/7t/137hx7xn4s1fdqvjj1bhtdhskm0vyc/T/tmpq2R_Bi'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/cache.html#clean_up_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.cache.clean_up_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a cache dir.</p>
<p>Designed to be called at program exit. and/or when
individual cache objects are deleted</p>
<p>raises a warning if there is problem deleting a particular directory</p>
</dd></dl>

<dl class="class">
<dt id="gnome.utilities.cache.ElementCache">
<em class="property">class </em><code class="descclassname">gnome.utilities.cache.</code><code class="descname">ElementCache</code><span class="sig-paren">(</span><em>cache_dir=None</em>, <em>enabled=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/cache.html#ElementCache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.cache.ElementCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Cache for element data &#8211; i.e. the data associated with the particles.
This caches UncertainSpillContainerPair
The cache can be accessed to re-draw the LE movies, etc.</p>
<dl class="docutils">
<dt>TODO: This is a really fragile module in terms of handling multiple</dt>
<dd>instances.  The __del__() method of previous instances can clear
the _cache_dir at the whim of the GC.
We may want to manage this differently.</dd>
</dl>
<p>initialize a new cache object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cache_dir=None</strong> &#8211; full path to the directory where the cache
should be stored.
If not provided, a temp dir will be created by
the python tempfile module</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gnome.utilities.cache.ElementCache.save_timestep">
<code class="descname">save_timestep</code><span class="sig-paren">(</span><em>step_num</em>, <em>spill_container_pair</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/cache.html#ElementCache.save_timestep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.cache.ElementCache.save_timestep" title="Permalink to this definition">¶</a></dt>
<dd><p>add a time step of data to the cache</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_num</strong> &#8211; the step number of the data</li>
<li><strong>spill_container</strong> &#8211; the spill container at this step</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.cache.ElementCache.load_timestep">
<code class="descname">load_timestep</code><span class="sig-paren">(</span><em>step_num</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/cache.html#ElementCache.load_timestep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.cache.ElementCache.load_timestep" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SpillContainer with the data arrays cached on disk</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step_num</strong> &#8211; the step number you want to load.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gnome.utilities.cache.ElementCache.rewind">
<code class="descname">rewind</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/utilities/cache.html#ElementCache.rewind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.utilities.cache.ElementCache.rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewinds the cache &#8211; clearing out everything</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gnome.persist.base_schema">
<span id="gnome-persist-pygnome-persistance-classes"></span><h2><code class="docutils literal"><span class="pre">gnome.persist</span></code> &#8211; PyGnome persistance classes<a class="headerlink" href="#module-gnome.persist.base_schema" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gnome.persist.base_schema.ObjType">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">ObjType</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#ObjType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.ObjType" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the obj_type which is stored by all gnome objects when persisting
to save files
It also optionally stores the &#8216;id&#8217; if present</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.CollectionItemMap">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">CollectionItemMap</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#CollectionItemMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.CollectionItemMap" title="Permalink to this definition">¶</a></dt>
<dd><p>This stores the obj_type and obj_index</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.LongLat">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">LongLat</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#LongLat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.LongLat" title="Permalink to this definition">¶</a></dt>
<dd><p>Only contains 2D (long, lat) positions</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.LongLatBounds">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">LongLatBounds</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#LongLatBounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.LongLatBounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to define bounds on a map</p>
</dd></dl>

<dl class="attribute">
<dt id="gnome.persist.base_schema.Polygon">
<code class="descclassname">gnome.persist.base_schema.</code><code class="descname">Polygon</code><a class="headerlink" href="#gnome.persist.base_schema.Polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#gnome.persist.base_schema.LongLatBounds" title="gnome.persist.base_schema.LongLatBounds"><code class="xref py py-class docutils literal"><span class="pre">LongLatBounds</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.WorldPoint">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">WorldPoint</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#WorldPoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.WorldPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to define reference points. 3D positions (long,lat,z)</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.WorldPointNumpy">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">WorldPointNumpy</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#WorldPointNumpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.WorldPointNumpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Define same schema as WorldPoint; however, the base class NumpyFixedLenSchema
serializes/deserializes it from/to a numpy array</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.base_schema.ImageSize">
<em class="property">class </em><code class="descclassname">gnome.persist.base_schema.</code><code class="descname">ImageSize</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/base_schema.html#ImageSize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.base_schema.ImageSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Only contains 2D (long, lat) positions</p>
</dd></dl>

<span class="target" id="module-gnome.persist.extend_colander"></span><p>Extend colander&#8217;s basic types for serialization/deserialization
of gnome specific types</p>
<dl class="class">
<dt id="gnome.persist.extend_colander.DefaultTuple">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">DefaultTuple</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#DefaultTuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.DefaultTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>A Tuple subclass that provides defaults from child nodes.</p>
<p>Required because Tuple returns <cite>colander.null</cite> by default
when <code class="docutils literal"><span class="pre">appstruct</span></code> is not provided, instead of creating a Tuple of
default values.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.NumpyFixedLen">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">NumpyFixedLen</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#NumpyFixedLen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.NumpyFixedLen" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.Tuple</span></code> that converts itself to a Tuple and
back to a numpy array. This is used to define schemas for Numpy arrays that
have a fixed size like WorldPoint, 3D velocity of SimpleMover.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.NumpyArray">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">NumpyArray</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#NumpyArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.NumpyArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.List</span></code> that converts itself to a more general
numpy array of greater than length 1.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.DatetimeValue2dArray">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">DatetimeValue2dArray</code><span class="sig-paren">(</span><em>accept_scalar=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#DatetimeValue2dArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.DatetimeValue2dArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.Sequence</span></code> that converts itself to a numpy
array using <code class="xref py py-class docutils literal"><span class="pre">gnome.basic_types.datetime_value_2d</span></code> as the data type.</p>
<dl class="docutils">
<dt>todo: serialize/deserialize must happen for each element - not very</dt>
<dd>efficient.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.DatetimeValue1dArray">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">DatetimeValue1dArray</code><span class="sig-paren">(</span><em>accept_scalar=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#DatetimeValue1dArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.DatetimeValue1dArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <code class="xref py py-class docutils literal"><span class="pre">colander.Sequence</span></code> that converts itself to a numpy
array using <code class="xref py py-class docutils literal"><span class="pre">gnome.basic_types.datetime_value_2d</span></code> as the data type.</p>
</dd></dl>

<dl class="class">
<dt id="gnome.persist.extend_colander.TimeDelta">
<em class="property">class </em><code class="descclassname">gnome.persist.extend_colander.</code><code class="descname">TimeDelta</code><a class="reference internal" href="_modules/gnome/persist/extend_colander.html#TimeDelta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.extend_colander.TimeDelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a type to serialize/deserialize timedelta objects</p>
</dd></dl>

<span class="target" id="module-gnome.persist.validators"></span><p>Created on Feb 26, 2013</p>
<p>Define general purpose functions that can used as validators</p>
<dl class="function">
<dt id="gnome.persist.validators.convertible_to_seconds">
<code class="descclassname">gnome.persist.validators.</code><code class="descname">convertible_to_seconds</code><span class="sig-paren">(</span><em>node</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/validators.html#convertible_to_seconds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.validators.convertible_to_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>validate only datetime objects</p>
</dd></dl>

<dl class="function">
<dt id="gnome.persist.validators.no_duplicate_datetime">
<code class="descclassname">gnome.persist.validators.</code><code class="descname">no_duplicate_datetime</code><span class="sig-paren">(</span><em>node</em>, <em>values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/validators.html#no_duplicate_datetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.validators.no_duplicate_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for duplicate datetime values in numpy structured array like
datetime_value_2d
Reject <code class="docutils literal"><span class="pre">values</span></code> if it contains duplicates.</p>
</dd></dl>

<dl class="function">
<dt id="gnome.persist.validators.ascending_datetime">
<code class="descclassname">gnome.persist.validators.</code><code class="descname">ascending_datetime</code><span class="sig-paren">(</span><em>node</em>, <em>values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gnome/persist/validators.html#ascending_datetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gnome.persist.validators.ascending_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the datetime values in numpy structured array
(like datetime_value_2d)
are in ascending order</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PyGnome Class Reference</a><ul>
<li><a class="reference internal" href="#gnome-model-the-pygnome-model-class"><code class="docutils literal"><span class="pre">gnome.model</span></code> &#8211; the PyGnome model class</a></li>
<li><a class="reference internal" href="#module-gnome.map"><code class="docutils literal"><span class="pre">gnome.map</span></code> &#8211; the PyGnome map class</a></li>
<li><a class="reference internal" href="#module-gnome.spill"><code class="docutils literal"><span class="pre">gnome.spill</span></code> &#8211; classes in the spill module</a></li>
<li><a class="reference internal" href="#module-gnome.spill.elements.element_type"><code class="docutils literal"><span class="pre">gnome.spill.elements</span></code> &#8211; classes in the elements module</a></li>
<li><a class="reference internal" href="#module-gnome.movers"><code class="docutils literal"><span class="pre">gnome.movers</span></code> &#8211; PyGnome mover classes</a></li>
<li><a class="reference internal" href="#module-gnome.weatherers"><code class="docutils literal"><span class="pre">gnome.weatherers</span></code> &#8211; PyGnome/Adios weathering/mass removal classes</a></li>
<li><a class="reference internal" href="#module-gnome.environment"><code class="docutils literal"><span class="pre">gnome.environment</span></code> &#8211; PyGnome environment classes</a></li>
<li><a class="reference internal" href="#module-gnome.outputters"><code class="docutils literal"><span class="pre">gnome.outputter</span></code> &#8211; PyGnome outputters module</a></li>
<li><a class="reference internal" href="#module-gnome.utilities.distributions"><code class="docutils literal"><span class="pre">gnome.utilities</span></code> &#8211; PyGnome utilities module</a></li>
<li><a class="reference internal" href="#module-gnome.persist.base_schema"><code class="docutils literal"><span class="pre">gnome.persist</span></code> &#8211; PyGnome persistance classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="scripting/mixedlayer_release.html"
                        title="previous chapter">A subsurface (mixed layer) release</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="units.html"
                        title="next chapter">Units used in GNOME / PyGNOME</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/reference.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units used in GNOME / PyGNOME"
             >next</a> |</li>
        <li class="right" >
          <a href="scripting/mixedlayer_release.html" title="A subsurface (mixed layer) release"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyGNOME 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, NOAA Emergecny Response Division.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>