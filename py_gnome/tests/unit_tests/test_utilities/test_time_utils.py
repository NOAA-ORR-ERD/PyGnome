#!/usr/bin/env python

"""
test time_utils different input formats
"""
from datetime import datetime, timedelta
import numpy as np
import pytest


from gnome.utilities.time_utils import (date_to_sec,
                                        sec_to_date,
                                        round_time,
                                        zero_time,
                                        UTC,
                                        FixedOffset,
                                        )


def _convert(x):
    """
    helper method for the next 4 tests
    """
    y = date_to_sec(x)

    return sec_to_date(y)


def test_scalar_input():
    """
    test time_utils conversion return a scalar if that is what the user input

    always returns a numpy object
    """

    x = datetime.now()
    xn = _convert(x)
    assert isinstance(xn, datetime)

    x = round_time(x, roundTo=1)
    assert isinstance(x, datetime)
    assert x == xn

    # numpy scalar
    x = np.datetime64(datetime.now())
    xn = _convert(x)
    assert isinstance(xn, datetime)


def test_datetime_array():
    """
    test time_utils conversion works for python datetime object
    """

    x = np.array([datetime.utcfromtimestamp(zero_time())] * 3,
                 dtype=datetime)
    xn = _convert(x)

    assert np.all(round_time(x, roundTo=1) == xn)


def test_numpy_array():
    """
    time_utils works for numpy datetime object
    """

    x = np.array([datetime.utcfromtimestamp(zero_time())] * 3,
                 dtype='datetime64[s]')

    xn = _convert(x)
    assert np.all(x == xn)


def test_time_dst():
    """
    test it works for datetime at 23 hours with daylight savings on
    test is only valid for places that have daylight savings time
    """

    x = datetime(2013, 3, 21, 23, 10)
    xn = _convert(x)
    assert np.all(x == xn)

    x = datetime(2013, 2, 21, 23, 10)  # no daylight savings
    xn = _convert(x)
    assert np.all(x == xn)

datetimes_crossing_dst_spring = [(datetime(2016, 3, 13, 0, 30)),  # spring
                                 (datetime(2016, 3, 13, 1, 0)),
                                 (datetime(2016, 3, 13, 1, 30)),
                                 (datetime(2016, 3, 13, 2, 0)),
                                 (datetime(2016, 3, 13, 2, 30)),
                                 (datetime(2016, 3, 13, 3, 0)),
                                 ]

datetimes_crossing_dst_fall = [(datetime(2016, 11, 6, 0, 0)),  # fall
                               (datetime(2016, 11, 6, 0, 30)),
                               (datetime(2016, 11, 6, 1, 0)),
                               (datetime(2016, 11, 6, 1, 30)),
                               (datetime(2016, 11, 6, 2, 0)),
                               (datetime(2016, 11, 6, 2, 30)),
                               ]


@pytest.mark.parametrize("dt", datetimes_crossing_dst_spring + datetimes_crossing_dst_fall)
def test_round_trip_dst(dt):
    # does it round-trip?
    assert dt == sec_to_date(date_to_sec(dt))


def test_to_sec_dst_transition_spring():
    seconds = date_to_sec(datetimes_crossing_dst_spring)

    # checks that the interval is constant -- i.e. no repeated or skipped times
    assert not np.any(np.diff(np.diff(seconds)))


def test_to_sec_dst_transition_fall():
    seconds = date_to_sec(datetimes_crossing_dst_fall)

    # checks that the interval is constant -- i.e. no repeated or skipped times
    assert not np.any(np.diff(np.diff(seconds)))


def test_to_date_dst_transition_spring():
    # these are hard coded from what was generated by date_to_sec
    # they cross the spring transition, and caused a problem.
    seconds = np.array([1457857800, 1457859600, 1457861400,
                        1457863200, 1457865000, 1457866800],
                       dtype=np.uint32)

    dates = sec_to_date(seconds)
    diff = np.diff(dates).astype(np.int64)
    print "difference:", diff
    # checks that the interval is constant -- i.e. no repeated or skipped times
    assert not np.any(np.diff(diff))


def test_to_date_dst_transition_fall():
    seconds = date_to_sec(datetimes_crossing_dst_fall)
    print seconds

    assert False
#    # checks that the interval is constant -- i.e. no repeated or skipped times
#    assert not np.any(np.diff(np.diff(seconds)))


def test_FixedOffset():
    """
    not sure what to test here, but at least make sure it gets called
    """
    tz = FixedOffset(8 * 60, "PST")

    assert tz.utcoffset(datetime(2016, 1, 1)) == timedelta(hours=8)
    assert tz.tzname(datetime(2016, 1, 1)) == "PST"
    assert tz.dst(datetime(2016, 1, 1)) == 0  # Jan, should not be DST
    assert tz.dst(datetime(2016, 7, 1)) == 0  # July, should be DST if it were there


def test_UTC():
    """
    not sure what to test here, but at least make sure it gets called
    """
    tz = UTC()

    print tz
    assert tz.utcoffset(datetime(2016, 1, 1)) == timedelta(hours=0)
    assert tz.tzname(datetime(2016, 1, 1)) == "UTC"
    assert tz.dst(datetime(2016, 1, 1)) == 0  # Jan, should not be DST
    assert tz.dst(datetime(2016, 7, 1)) == 0  # July, should be DST if it were there


def test_datetime64_dst():
    """
    really a test of datetime64, but where else to put it?
    """
    dts = [(datetime(2016, 3, 13, 0, 0)),  # spring
           (datetime(2016, 3, 13, 0, 30)),
           (datetime(2016, 3, 13, 1, 0)),
           (datetime(2016, 3, 13, 1, 30)),
           (datetime(2016, 3, 13, 2, 0)),
           (datetime(2016, 3, 13, 2, 30)),
           (datetime(2016, 3, 13, 3, 0)),
           (datetime(2016, 3, 13, 3, 30)),
           (datetime(2016, 3, 13, 4, 0)),
           (datetime(2016, 11, 6, 0, 0)),  # fall
           (datetime(2016, 11, 6, 0, 30)),
           (datetime(2016, 11, 6, 1, 0)),
           (datetime(2016, 11, 6, 1, 30)),
           (datetime(2016, 11, 6, 2, 0)),
           (datetime(2016, 11, 6, 2, 30)),
           (datetime(2016, 11, 6, 3, 0)),
           ]

    # do they round-trip?
    for dt in dts:
        assert dt == np.datetime64(dt).astype(datetime)

    # do they round-trip if you process as an array?
    dt_arr = np.array(dts, dtype='datetime64[s]')
    dt_list = dt_arr.astype(datetime).tolist()

    for d in dt_list:
        print d

    assert dt_list == dts
